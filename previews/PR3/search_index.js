var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<style>\ndl {\ndisplay: grid;\ngrid-template-columns: max-content auto;\n}\ndt {\ngrid-column-start: 1;\n}\ndd {\ngrid-column-start: 2;\nmargin-bottom: 0.75em;\n}\n</style>\n<div id=\"horgrid\">","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"references/","page":"References","title":"References","text":"</div>","category":"page"},{"location":"guides/#Guides","page":"Guides","title":"Guides","text":"","category":"section"},{"location":"guides/","page":"Guides","title":"Guides","text":"Pages = [\"guides.md\"]\nDepth = 3","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"This project will not be published as a Julia Package as it is a interim project. Therefore you will have to clone it from GitHub instead of using the convenient Pkg.add(\"<Packagename>\") command.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"TODO: polish this and add a MagMechFEM_Matlab2Julia example instead of the NURBStoolbox one","category":"page"},{"location":"guides/#How-to-download-and-try-the-project","page":"Guides","title":"How to download and try the project","text":"","category":"section"},{"location":"guides/","page":"Guides","title":"Guides","text":"This guide aims at first time Julia and Git users. And will lead to a one way copy of the project on your machine. This is a short guide on how to download the project and start experimenting with it.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"I assume that you:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"have Julia on your system,\nhave Git on your system,\nand that you know how to work with a terminal.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"On your working directory download the current state of the git repository with:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git clone https://github.com/LazyScholar/MagMechFEM_Matlab2Julia.git","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"This will create a local copy of this project in your working directory.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Change into the created subdirectory MagMechFEM_Matlab2Julia.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"cd MagMechFEM_Matlab2Julia","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Now start Julia with the command:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"julia","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"This will start the Julia REPL (assuming you set up Julia correctly). Now we will activate the current project by typing in:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"using Pkg\nPkg.activate(\".\")\nPkg.instantiate()","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Which loads the module Pkg, activates the current path as project directory and installs all dependencies.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Now you should be able to load the project module with the command:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"using MagMechFEM_Matlab2Julia","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"This pre-compiles the package (btw. Julia has tab completion). Now you can use it.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Try to use one of the NURBStoolbox demos e.g.:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"MagMechFEM_Matlab2Julia.NURBStoolbox.demoruled()","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"You might have to explicitly install Pkg.add(\"PyPlot\") or further packages as those might not be fully tracked or need a manual instal (Julia should tell you that in the error messages).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"In order to build the documentation on your machine you can run.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"include(\"docs/make.jl\")","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"To run the package tests use the command.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Pkg.test()","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"If you have Jupyter installed you might want to convert one of the example files into a notebook by:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"using Literate\nLiterate.notebook(\"docs/literate/ex_NURBStoolbox.jl\",joinpath(pwd(),\"docs/notebooks/\"))","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"This will create a Jupyter notebook in the directory docs/notebooks (keep in mind to install the Julia kernel for Jupyter).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"To get updates of the repository (without deleting the directory and cloning again) add a remote with the shell command","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git remote add origin https://github.com/LazyScholar/MagMechFEM_Matlab2Julia.git","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"from the cloned subdirectory MagMechFEM_Matlab2Julia. You can use git remote to check if you have remotes registered with your local copy. The name origin for the remote is arbitrary, and you can choose another name.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"To get all changes onto your machine execute","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git fetch --all","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"which gets you all changes of the remote repository without changing your local copy yet.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Now you can update or change your local state to the newest one with","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git pull","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":", be aware that this might overwrite against local changes you have done.","category":"page"},{"location":"guides/#How-to-contribute-with-Git","page":"Guides","title":"How to contribute with Git","text":"","category":"section"},{"location":"guides/","page":"Guides","title":"Guides","text":"This is a short guide on how to contribute to the project and work with it. And aims at first time contributors and Git users (verterans should skim it and have a look at the TODO: contribution rules). I assume here that you","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"know how to work with Julia,\nhave read, understood and accept the TODO: contribution rules,\nhave Git on your system,\nhave a GitHub account,\nand are fairly confident in working with Linux and the command line.","category":"page"},{"location":"guides/#How-to-contribute-to-a-GitHub-project-in-general","page":"Guides","title":"How to contribute to a GitHub project in general","text":"","category":"section"},{"location":"guides/","page":"Guides","title":"Guides","text":"First you have to fork the project (this step is unnecessary for users that have commit access to the project). In order to do this you have to fork/copy the repository into your own account. To do this just click on the fork button on the main project page.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"(Image: GitHub Fork Button)","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Now you can clone your copy of the project onto your machine. To do this you can click on the green code button","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"(Image: GitHub Clone Button)","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"on the main page of your copy. There you will be provided with some options on how to clone the repository. I recommend using either the https or ssh option which will provide you with an address for the","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":" git clone <ADDRESS>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"command. Use this command in a directory where you want to place your copy by substituting <ADDRESS>.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Note that the ssh option might be a bit cumbersome to set up but will facilitate the work with GitHub noticeable if you plan to use remote commands heavily. It is possible to switch between those options later on (do not use the ssh solution on untrusted machines).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Now you change into the directory of your local copy","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"cd MagMechFEM_Matlab2Julia","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"and create a branch to work on (the name of the branch is arbitrary but should be short and expressive).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git checkout -b <BRANCH NAME>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Note that you can also check out another state of the project or another branch in order to branch of from or build upon that specific state.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"This branch will contain your commits (changes) you will make. In order to add changes to your branch you can use","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git status","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"to get an overview of current changes (green ones are staged and red ones untracked changes). The command","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git add <change>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"will add certain changes (substitute <change> with one of the red outputs of git status).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"There are multiple other ways to manage your staged changes some are e.g. git add --all which will add all current changes or the use of a GUI frontend like those of code IDEs or editors. With time you will discover these and choose appropriate or fitting ones for you. This certainly applies also to the guide provided here.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"If you are satisfied with your current work you can commit (add the changes) to your current branch. By typing","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git commit -m \"<Very short and expressive summary of your changes.>\"","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"which will add your staged changes to the branch. You can accumulate more of them or follow the next steps.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"In order to upload you changes to your online repository you might have to check under which name your remote repository is registered. Use git remote for that.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"The git remote commands are also the place you have to look at if you want to change your https based workflow to a ssh based one (and vice versa).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"For this example the remote is registered with the name origin. And you can push your changes to your online fork with","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git push origin <BRANCH NAME>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"which will either add this branch to the fork or update it if you already pushed some changes there.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"If you think your overall changes are ready to be incorporated into the original repository you can start a pull request. For this you have to click on the pull request button","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"(Image: GitHub Pull Request Button)","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"while you are on your branch containing your changes you want to add. This will open a pull request to the original repository. Feel free to enrich the pull request message with notes and further information describing your changes.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Note that this guide assumes that your changes can be cleanly incorporated into the main repository or the branch you are targeting with your pull request.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"You can add further commits to your pull request by simply pushing them to your online branch till the request has been closed.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"If the code owners accept your pull request and your work is done you can delete your local copy (just delete the directory) and your GitHub fork.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"If not you might want to sync your local copy with the original repository after your changes where added. To do this you have to add the repository to the remote list of your local copy. Get the https or ssh address of the original repository like you got your address above. And use the command","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git remote add <name of orignial repository> <ADDRESS of original repository>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"to add the <ADDRESS of original repository> under the identifier <name of orignial repository> (the command git remote should now provide two different names). The <name of orignial repository> is arbitrary like above (use a short and expressive one like original or upstream).","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"Now change to the main branch (or any branch you want to update) with","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git checkout main","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"and issue the command","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git fetch <name of orignial repository>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"to download the state of the repository and use","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git merge <name of orignial repository>/main","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"to merge the changes into your local copy (the branch names should be identical). To furthermore update your own online fork use the command.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git push origin main","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"You might want to delete your working branch as it should have served its purpose.","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"git branch -d <BRANCH NAME>\ngit push origin --delete <BRANCH NAME>","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"The last command will delete the online copy of your branch.","category":"page"},{"location":"guides/#How-to-contribute-to-this-project-and-further-notes","page":"Guides","title":"How to contribute to this project and further notes","text":"","category":"section"},{"location":"guides/","page":"Guides","title":"Guides","text":"TODO: add GIT contrib guide\nTODO: add stable version (stable branch/ dev branch?)\nTODO: add how to add tests and run the tests\nTODO: add how to add documentation and check it localy\nTODO: add how to check remote documentation build\nTODO: add ...","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"To build the documentation locally change to the main directory of the project and issue those Julia commands:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"using Pkg\nPkg.activate(\".\")\ninclude(\"docs/make.jl\")","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"To run the tests of the project and its sub modules change to the main directory of the project and issue the following Julia commands:","category":"page"},{"location":"guides/","page":"Guides","title":"Guides","text":"using Pkg\nPkg.activate(\".\")\nPkg.test()","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"EditURL = \"https://github.com/LazyScholar/MagMechFEM_Matlab2Julia/blob/master/docs/literate/nb_bernstein_polynomials.jl\"","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"using Plots;\nPlots.reset_defaults(); #hide\ndefault(background_color=:transparent, #hide\n        foreground_color=:grey, #hide\n        html_output_format=:svg); #hide\nnothing #hide","category":"page"},{"location":"literate/nb_bernstein_polynomials/#Bernstein-Polynomials","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"","category":"section"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"These notes are partially based on the NURBS Book from Les Piegl, Wayne Tiller (1997).","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"p = 4;\nxi = range(0,1,length=40);\nξ = range(-1,1,length=length(xi));\nnothing #hide","category":"page"},{"location":"literate/nb_bernstein_polynomials/#Bernstein-Polynomials-[0,1]","page":"Bernstein Polynomials","title":"Bernstein Polynomials [0,1]","text":"","category":"section"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"According to Les Piegl, Wayne Tiller (1997) the iinleft0pright_mathbbZ Bernstein Polynomials","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_ipleft(xiright) =\nfracpi left(p-iright) xi^i left(1-xiright)^p-i\nquad forall quad xiinleft01right_mathbbR","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"of the polynomial degree p","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"B = transpose(factorial(p)./(factorial.(0:p).*factorial.(p .- (0:p))));\nB = xi.^(transpose(0:p)).*(1 .- xi).^(p .- transpose(0:p)) .* B;\nplot(xi,B,\n     label = [\"\\$\\\\operatorname{B}_{$x,$p}\" *\n              \"\\\\left(\\\\xi\\\\right)\\$\" for x in (0:p)'],\n     color = (1:p+1)',\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$\\\\xi\\$\",\n     ylabel = \"\\$\\\\operatorname{B}_{i,p}\\\\left(\\\\xi\\\\right)\\$\",\n     widen = false);\nnothing #hide","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"can be defined recursively. The definition","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_ipleft(xiright) =\nxi  operatornameB_i-1p-1left(xiright) +\nleft(1-xiright)  operatornameB_ip-1left(xiright)","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"according to the recursive algorithm A1.3 from Les Piegl, Wayne Tiller (1997) with the additional restrictions","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_00left(xiright) = 1 text and \noperatornameB_ipleft(xiright) = 0  forall  i0 lor ip","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"will lead to the same Bernstein Polynomials.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"B = zeros(typeof(1.0),(length(xi),p+1));\nB[:,1] .= 1;\nxi_compl = 1 .- xi;\ntemp_0 = zeros(typeof(1.0),length(xi));\ntemp_1 = zeros(typeof(1.0),length(xi));\nfor j in 2:p+1\n  temp_0 .= 0;\n  for k in 1:j-1\n    temp_1 .= B[:,k];\n    B[:,k] .= temp_0 .+ xi_compl .* temp_1;\n    temp_0 .= xi .* temp_1;\n  end # for k\n  B[:,j] .= temp_0;\nend # for j\nplot!(xi,B,\n      label = [\"\\$\\\\operatorname{B}_{$x,$p}\" *\n               \"\\\\left(\\\\xi\\\\right)\\$\" for x in (0:p)'],\n      color = (1:p+1)',\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0)","category":"page"},{"location":"literate/nb_bernstein_polynomials/#Derivatives-of-Bernstein-Polynomials-[0,1]","page":"Bernstein Polynomials","title":"Derivatives of Bernstein Polynomials [0,1]","text":"","category":"section"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"The derivatives for the Bernstein Polynomials","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_ipleft(xiright) =\nfracpi left(p-iright) xi^i left(1-xiright)^p-i","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"on the definition area xiinleft01right_mathbbR","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"beginaligned\nfracmathrmdmathrmdxi operatornameB_ipleft(xiright)\n=\nfracpileft(p-iright)\nlefti  xi^i-1 left(1-xiright)^p-i - xi^i left(p-iright)\n left(1-xiright)^p-i-1right \n\n=\np  leftfracleft(p-1right)left(i-1right)left(p-iright) \nxi^i-1 left(1-xiright)^p-i -\nfracleft(p-1right)ileft(p-i-1right)\nxi^i  left(1-xiright)^p-i-1right\nendaligned","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"can be build with Bernstein Polynomials of a lesser degree","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"fracmathrmdmathrmdxi operatornameB_ipleft(xiright) =\np  leftoperatornameB_i-1p-1left(xiright) -\noperatornameB_ip-1left(xiright)right","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"with operatornameB_ip-1left(xiright) = 0  forall  i0 lor i geq p.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"The second derivatives","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"beginaligned\nfracmathrmd^2mathrmdxi^2\noperatornameB_ipleft(xiright)\n=\np  leftfracleft(p-1right)left(i-1right)left(p-iright) \nleft left(i-1right)  xi^i-2 left(1-xiright)^p-i -\nxi^i-1 left(p-iright)  left(1-xiright)^p-i-1 right -\nfracleft(p-1right)ileft(p-i-1right)  left i  xi^i-1 \nleft(1-xiright)^p-i-1 - xi^i  left(p-i-1right) \nleft(1-xiright)^p-i-2 right right \n\n=\np  left(p-1right)  left left\nfracleft(p-2right)left(i-2right)left(p-iright) \nxi^i-2 left(1-xiright)^p-i -\nfracleft(p-2right)left(i-1right)left(p-i-1right) \nxi^i-1 left(1-xiright)^p-i-1 right -\nleftfracleft(p-2right)left(i-1right)left(p-i-1right) \nxi^i-1  left(1-xiright)^p-i-1 -\nfracleft(p-2right)ileft(p-i-2right)  xi^i \nleft(1-xiright)^p-i-2  right right\nendaligned","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"can be defined with Bernstein Polynomials of two times lower degrees","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"beginaligned\nfracmathrmd^2mathrmdxi^2\noperatornameB_ipleft(xiright)\n=\np  left fracmathrmdmathrmdxi\noperatornameB_i-1p-1left(xiright) -\nfracmathrmdmathrmdxi\noperatornameB_ip-1left(xiright)right \n\n=\np  left(p-1right) left left\noperatornameB_i-2p-2left(xiright) -\noperatornameB_i-1p-2left(xiright) right - left\noperatornameB_i-1p-2left(xiright) -\noperatornameB_i  p-2left(xiright)\nright right\nendaligned","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"with operatornameB_ip-2left(xiright)=0  forall  i0 lor i geq p-1.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"And the third derivatives","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"beginaligned\nfracmathrmd^3mathrmdxi^3\noperatornameB_ipleft(xiright)\n=\np  left fracmathrmd^2mathrmdxi^2\noperatornameB_i-1p-1left(xiright) -\nfracmathrmd^2mathrmdxi^2\noperatornameB_ip-1left(xiright)right \n\n=\np  left(p-1right) left left\nfracmathrmdmathrmdxioperatornameB_i-2p-2left(xiright)\n-\nfracmathrmdmathrmdxioperatornameB_i-1p-2left(xiright)\nright -  left\nfracmathrmdmathrmdxioperatornameB_i-1p-2left(xiright)\n-\nfracmathrmdmathrmdxioperatornameB_ip-2left(xiright)\nright right\nendaligned","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"with operatornameB_ip-3left(xiright)=0  forall  i0 lor i geq p-2 follow the same rule and can be defined with Polynomials of three times lower degrees.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"Considering the pattern one can define the k-th derivatives of the Bernstein Polynomials with the recursive formula","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"fracmathrmd^kmathrmdxi^k\noperatornameB_ipleft(xiright)= left(p-k+1right) \nleftfracmathrmd^k-1mathrmdxi^k-1\noperatornameB_i-1p-1left(xiright) -\nfracmathrmd^k-1mathrmdxi^k-1\noperatornameB_ip-1left(xiright)right","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"with fracmathrmd^0mathrmdxi^0 operatornameB_ipleft(xiright) = operatornameB_ipleft(xiright) and operatornameB_ip-kleft(xiright)=0  forall  i0 lor i geq p-k+1.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"Therefore one could calculate the derivatives while also calculating the Bernstein Polynomials recursively.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"Here the calculation scheme for Bernstein Polynomials of the degree p=3","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"beginmatrix\n            B_03 cr\n          nearrow    cr\nB_-10        B_02     cr\n     nearrow    searrow   cr\n    B_01        B_13cr\n  nearrow    searrow    nearrow    cr\nB_00        B_12     cr\n  searrow    nearrow    searrow    cr\n    B_11        B_23 cr\n      searrow    nearrow    cr\nB_10        B_22     cr\n          searrow    cr\n            B_33 cr\nendmatrix","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"and the corresponding schemes for the derivatives","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"beginarrayccc\nbeginmatrix\n    fracmathrmdmathrmdxiB_03 cr\n  nearrow   cr\nB_02     cr\n  searrow   cr\n    fracmathrmdmathrmdxiB_13 cr\n  nearrow   cr\nB_12     cr\n  searrow   cr\n    fracmathrmdmathrmdxiB_23 cr\n  nearrow   cr\nB_22     cr\n  searrow   cr\n    fracmathrmdmathrmdxiB_33 cr\nendmatrix\n\nbeginmatrix\n        fracmathrmd^2mathrmdxi^2B_03 cr\n      nearrow   cr\n    B_02     cr\n  nearrow    searrow   cr\nB_01        fracmathrmd^2mathrmdxi^2B_13 cr\n  searrow    nearrow   cr\n    B_12     cr\n  nearrow    searrow   cr\nB_11        fracmathrmd^2mathrmdxi^2B_23 cr\n  searrow    nearrow   cr\n    B_22     cr\n      searrow   cr\n        fracmathrmd^2mathrmdxi^2B_33 cr\nendmatrix\n\nbeginmatrix\n       fracmathrmd^3mathrmdxi^3B_03 cr\n          nearrow    cr\nB_-10        B_02     cr\n     nearrow    searrow   cr\n B_01   fracmathrmd^3mathrmdxi^3B_13cr\n  nearrow    searrow    nearrow    cr\nB_00        B_12     cr\n  searrow    nearrow    searrow    cr\n B_11  fracmathrmd^3mathrmdxi^3B_23 cr\n      searrow    nearrow    cr\nB_10        B_22     cr\n          searrow    cr\n       fracmathrmd^3mathrmdxi^3B_33 cr\nendmatrix\nendarray","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"B = zeros(typeof(1.0),(length(xi),p+1));\ndB = Vector{typeof(B)}(undef,p);\nB[:,1] .= 1;\nxi_compl = 1 .- xi;\ntemp_0 = zeros(typeof(1.0),length(xi));\ntemp_1 = zeros(typeof(1.0),length(xi));\ntemp_d0 = zeros(typeof(1.0),length(xi));\ntemp_d1 = zeros(typeof(1.0),length(xi));\nfor j in 2:p+1\n  temp_d = p-j+2;\n  dB[temp_d] = copy(B);\n  temp_m = 1;\n  for i in j:p+1\n    temp_m *= i-1;\n    temp_d0 .= 0;\n    for k in 1:i\n      temp_d1 .= dB[temp_d][:,k];\n      dB[temp_d][:,k] .= temp_d0 .- temp_d1;\n      temp_d0 .= temp_d1;\n    end # for k\n  end # for i\n  dB[temp_d] .*= temp_m;\n  temp_0 .= 0;\n  for k in 1:j-1\n    temp_1 .= B[:,k];\n    B[:,k] .= temp_0 .+ xi_compl .* temp_1;\n    temp_0 .= xi .* temp_1;\n  end # for k\n  B[:,j] .= temp_0;\nend # for j","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"pltL = Vector{Plots.Plot}(undef,p+1);\npltL[1] = plot(xi,B,ylabel = \"\\$\\\\operatorname{B}_{i,p}\\\\left(\\\\xi\\\\right)\\$\");\nfor d in 1:p\n  pltL[1+d] = plot(xi,dB[d]);\n  if d == 1\n    plot!(ylabel = \"\\$\\\\frac{\\\\mathrm{d}}{\\\\mathrm{d}\\\\xi}\\\\;\" *\n                   \"\\\\operatorname{B}_{i,p}\\\\left(\\\\xi\\\\right)\\$\");\n  else\n    plot!(ylabel = \"\\$\\\\frac{\\\\mathrm{d}^{$d}}{\\\\mathrm{d}\\\\xi^{$d}}\\\\;\" *\n                   \"\\\\operatorname{B}_{i,p}\\\\left(\\\\xi\\\\right)\\$\");\n  end # if\n  if d == p; plot!(xlabel = \"\\$\\\\xi\\$\"); end\nend # for d\nplot(pltL...,\n     layout = (p+1, 1),\n     legend = false,\n     border = :box,\n     color = (1:p+1)',\n     linewidth = 2,\n     widen = false,\n     size = (600, 800))","category":"page"},{"location":"literate/nb_bernstein_polynomials/#Bernstein-Polynomials-[-1,1]","page":"Bernstein Polynomials","title":"Bernstein Polynomials [-1,1]","text":"","category":"section"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"If we substitutes xi = frac12left(overlinexi+1right) into the definitions above we get","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_ipleft(overlinexiright) =\nfracpi left(p-iright) frac12^p\nleft(overlinexi+1right)^i left(1-overlinexiright)^p-i\nquad forall quad overlinexiinleft-11right_mathbbR","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"which is the definition for the Bernstein Polynomials on the linear standard FEM area overlinexiinleft-11right_mathbbR.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"B = transpose(factorial(p)./(factorial.(0:p).*factorial.(p .- (0:p)))) ./ 2^p;\nB = (ξ .+ 1).^(transpose(0:p)).*(1 .- ξ).^(p .- transpose(0:p)) .* B;\nplot(ξ,B,\n     label = [\"\\$\\\\operatorname{B}_{$x,$p}\" *\n              \"\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\" for x in (0:p)'],\n     color = (1:p+1)',\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$\\\\overline{\\\\xi}\\$\",\n     ylabel = \"\\$\\\\operatorname{B}_{i,p}\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\",\n     widen = false);\nnothing #hide","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"The recursive definition will change to","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_ipleft(overlinexiright)=\nfrac12leftleft(overlinexi+1right) \noperatornameB_i-1p-1left(overlinexiright) +\nleft(1-overlinexiright)\noperatornameB_ip-1left(overlinexiright)right","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"with the additional restrictions","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_00left(overlinexiright) = 1 text and \noperatornameB_ipleft(overlinexiright) = 0  forall  i0 lor\nip text ","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"B = zeros(typeof(1.0),(length(ξ),p+1));\nB[:,1] .= 1;\nξ0 = (ξ .+ 1) ./ 2;\nξ0_compl = (1 .- ξ) ./ 2;\ntemp_0 = zeros(typeof(1.0),length(ξ));\ntemp_1 = zeros(typeof(1.0),length(ξ));\nfor j in 2:p+1\n  temp_0 .= 0;\n  for k in 1:j-1\n    temp_1 .= B[:,k];\n    B[:,k] .= temp_0 .+ ξ0_compl .* temp_1;\n    temp_0 .= ξ0 .* temp_1;\n  end # for k\n  B[:,j] .= temp_0;\nend # for j\nplot!(ξ,B,\n      label = [\"\\$\\\\operatorname{B}_{$x,$p}\" *\n               \"\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\" for x in (0:p)'],\n      color = (1:p+1)',\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0)","category":"page"},{"location":"literate/nb_bernstein_polynomials/#Derivatives-of-Bernstein-Polynomials-[-1,1]","page":"Bernstein Polynomials","title":"Derivatives of Bernstein Polynomials [-1,1]","text":"","category":"section"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"The derivatives for the Bernstein Polynomials","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"operatornameB_ipleft(overlinexiright) = fracpi\nleft(p-iright) frac12^p left(overlinexi+1right)^i\nleft(1-overlinexiright)^p-i","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"on the linear FEM definition area overlinexiinleft-11right_mathbbR can be calculated like above. After either following the same steps or via substitution we can write the generalised derivation relation","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"fracmathrmd^kmathrmdoverlinexi^k\noperatornameB_ipleft(overlinexiright)= fracp-k+12 \nleftfracmathrmd^k-1mathrmdoverlinexi^k-1\noperatornameB_i-1p-1left(overlinexiright) -\nfracmathrmd^k-1mathrmdoverlinexi^k-1\noperatornameB_ip-1left(overlinexiright)right","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"with fracmathrmd^0mathrmdoverlinexi^0 operatornameB_ipleft(overlinexiright) = operatornameB_ipleft(overlinexiright) and operatornameB_ip-kleft(overlinexiright)=0  forall  i0 lor i geq p-k+1.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"The only difference is the changed argument variable and the factor frac12. Therefore the algorithm to calculate the derivatives has to be changed minimally.","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"B = zeros(typeof(1.0),(length(ξ),p+1));\ndB = Vector{typeof(B)}(undef,p);\nB[:,1] .= 1;\nξ0 = (ξ .+ 1) ./ 2;\nξ0_compl = (1 .- ξ) ./ 2;\ntemp_0 = zeros(typeof(1.0),length(ξ));\ntemp_1 = zeros(typeof(1.0),length(ξ));\ntemp_d0 = zeros(typeof(1.0),length(ξ));\ntemp_d1 = zeros(typeof(1.0),length(ξ));\nfor j in 2:p+1\n  temp_d = p-j+2;\n  dB[temp_d] = copy(B);\n  temp_m = 1;\n  for i in j:p+1\n    temp_m *= (i-1)/2;\n    temp_d0 .= 0;\n    for k in 1:i\n      temp_d1 .= dB[temp_d][:,k];\n      dB[temp_d][:,k] .= temp_d0 .- temp_d1;\n      temp_d0 .= temp_d1;\n    end # for k\n  end # for i\n  dB[temp_d] .*= temp_m;\n  temp_0 .= 0;\n  for k in 1:j-1\n    temp_1 .= B[:,k];\n    B[:,k] .= temp_0 .+ ξ0_compl .* temp_1;\n    temp_0 .= ξ0 .* temp_1;\n  end # for k\n  B[:,j] .= temp_0;\nend # for j","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"pltL = Vector{Plots.Plot}(undef,p+1);\npltL[1] = plot(ξ,B,ylabel = \"\\$\\\\operatorname{B}_{i,p}\" *\n                            \"\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\");\nfor d in 1:p\n  pltL[1+d] = plot(ξ,dB[d]);\n  if d == 1\n    plot!(ylabel = \"\\$\\\\frac{\\\\mathrm{d}}{\\\\mathrm{d}\\\\xi}\\\\;\" *\n                   \"\\\\operatorname{B}_{i,p}\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\");\n  else\n    plot!(ylabel = \"\\$\\\\frac{\\\\mathrm{d}^{$d}}{\\\\mathrm{d}\\\\xi^{$d}}\\\\;\" *\n                   \"\\\\operatorname{B}_{i,p}\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\");\n  end # if\n  if d == p; plot!(xlabel = \"\\$\\\\overline{\\\\xi}\\$\"); end\nend # for d\nplot(pltL...,\n     layout = (p+1, 1),\n     legend = false,\n     border = :box,\n     color = (1:p+1)',\n     linewidth = 2,\n     widen = false,\n     size = (600, 800))","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"","category":"page"},{"location":"literate/nb_bernstein_polynomials/","page":"Bernstein Polynomials","title":"Bernstein Polynomials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"EditURL = \"https://github.com/LazyScholar/MagMechFEM_Matlab2Julia/blob/master/docs/literate/nb_nurbs_1d.jl\"","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"using Plots;\ndefault(background_color=:transparent, #hide\n        foreground_color=:grey, #hide\n        html_output_format=:svg); #hide\nnothing #hide","category":"page"},{"location":"literate/nb_nurbs_1d/#D-NURBS","page":"NURBS 1D","title":"1D NURBS","text":"","category":"section"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"These notes are partially based on the NURBS Book from Les Piegl, Wayne Tiller (1997).","category":"page"},{"location":"literate/nb_nurbs_1d/#Definition","page":"NURBS 1D","title":"Definition","text":"","category":"section"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"The definition of NURBS curves mathbfCleft(xiright) of the polynomial degree p is according to Les Piegl, Wayne Tiller (1997)","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"beginaligned\nmathbfCleft(xiright)\n=\nsum_i=1^nfracoperatornameN_ipleft(xiright) w_i\nsum_k=1^noperatornameN_kpleft(xiright) w_k P_i \n\n=\nsum_i=1^nfracoperatornameN_ipleft(xiright) w_i\nmathbfwleft(xiright) P_i \n\n=\nsum_i=1^noperatornameR_ipleft(xiright) P_i\nendaligned","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"in which the operatornameN_ipleft(xiright) corresponds to the i-th B-Spline base functions defined as","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"operatornameN_ipleft(xiright) =\nbegincases\nbegincases\n1  text if  xi_i leq xi  xi_i+1 \n0  text else \nendcases  text if  p=0 \nfracxi-xi_ixi_i+p-xi_i \noperatornameN_ip-1left(xiright) +\nfracxi_i+p+1-xixi_i+p+1-xi_i+1 \noperatornameN_i+1p-1left(xiright)  text if  p  0\nendcases\nquad forall quad xiinleftxi_1xi_n+p+1right_mathbbR","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":". So the difference to B-Splines is the rational definition and the weights w_i which are stored as a column vector for each control point P_i.","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"mathbfP=\nleftbeginarrayc\nP_1crvdotscr P_icrvdotscr P_n\nendarrayright =\nleftbeginarrayccc\nP_1x  P_1y  P_1zcr\nvdots  vdots  vdotscr\nP_ix  P_iy  P_izcr\nvdots  vdots  vdotscr\nP_nx  P_ny  P_nz\nendarrayright\nquad  quad\nmathbfw=\nleftbeginarrayc\nw_1crvdotscr w_icrvdotscr w_n\nendarrayright","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"The relations between the knot vector mathbfXi = left(xi_1dotsxi_idotsxi_n+p+1right) and the iinleft1nright_mathbbZ the base functions did not change.","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"Therefore we can calculate the weight function mathbfwleft(xiright)=mathbfNleft(xiright)mathbfw either with the B-Spline base functions","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"function bspline_bf1(p::Integer,Ξ::Vector{typeof(1.0)},ξ::Vector{typeof(1.0)})\nn0 = length(Ξ)-1;\nN = zeros(typeof(1.0),(length(ξ),n0));\nN[(ξ .>= Ξ[1:n0]') .& (ξ .< Ξ[2:n0+1]')] .= 1.0;\nN[end , ξ[end] .<= Ξ[2:n0+1]] .= 1.0; # just to have it look nice\nfor k in 1:p\n  for i in 1:n0-k\n    temp_1 = (Ξ[i+k] - Ξ[i]);\n    temp_2 = (Ξ[i+k+1] - Ξ[i+1]);\n    if temp_1 != 0;\n      temp_1 = (ξ .- Ξ[i]) ./ temp_1;\n    else\n      temp_1 = zeros(typeof(1.0),length(ξ));\n    end # if\n    if temp_2 != 0;\n      temp_2 = (Ξ[i+k+1] .- ξ) ./ temp_2;\n    else\n      temp_2 = zeros(typeof(1.0),length(ξ));\n    end # if\n    N[:,i] .= temp_1 .* N[:,i] .+ temp_2 .* N[:,i+1];\n  end # for i\nend # for k\nreturn N[:,1:n0-p];\nend # bspline_bf1\nnothing #hide","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"or the 'de Boor recursion'.","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"After calculating mathbfwleft(xiright) we can define the NURBS base functions operatornameR_ipleft(xiright)","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"operatornameR_ipleft(xiright) =\nfracoperatornameN_ipleft(xiright) w_i\nmathbfwleft(xiright)","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"which we store similar to the B-Spline base functions mathbfNleft(xiright) in a row array mathbfRleft(xiright)","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"mathbfRleft(xiright) = left beginarrayccccc\noperatornameR_1pleft(xiright)  cdots \noperatornameR_ipleft(xiright)  cdots \noperatornameR_npleft(xiright)endarray right","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"which we can use to calculate the NURBS curve with a matrix multiplication.","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"mathbfCleft(xiright) = mathbfRleft(xiright)mathbfP","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"It is also possible to define homogeneous points mathbfP_w","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"mathbfP_w=\nleftbeginarraycc\nP_1w_1  w_1crvdots  vdotscr\nP_iw_i  w_icrvdots  vdotscr\nP_nw_n  w_n\nendarrayright =\nleftbeginarraycccc\nP_1xw_1  P_1yw_1  P_1zw_1  w_1cr\nvdots  vdots  vdots  vdots cr\nP_ixw_i  P_iyw_i  P_izw_i  w_icr\nvdots  vdots  vdots  vdots cr\nP_nxw_n  P_nyw_n  P_nzw_n  w_n\nendarrayright","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"calculate the NURBS curve in homogeneous space and transform it back with the weight curve mathbfwleft(xiright) (which will be calculated alongside the homogeneous curve).","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"mathbfCleft(xiright) =\nfracmathbfNleft(xiright)mathbfP_w\nmathbfwleft(xiright)","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"In this case the resulting mathbfC will have a additional column (filled with ones) which can be discarded afterwards.","category":"page"},{"location":"literate/nb_nurbs_1d/#Example","page":"NURBS 1D","title":"Example","text":"","category":"section"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"p = 2;\nΞ = vec([0.0 0 0 1 1 2 3.5 4 4 4]);\nP = [-4 -3 -1 0 1 2 4;\n      0  1  8 2 7 1 8;\n      0  0  0 0 0 0 0]'/8;\nweights = vec([1 1 1 1 1 1/4 1]);\nξ = collect(range(Ξ[1],Ξ[end],length=61));\nnothing #hide","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"N = bspline_bf1(p,Ξ,ξ);\nw = N * weights;\nR = (N .* weights') ./ w;\nC_bsp = N * P;\nC = R * P;\nnothing #hide","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"pltN = plot(ξ,N,\n            color = (1:size(N,2))',\n            label = [\"\\$\\\\operatorname{N}_{$x,$p}\" *\n                    \"\\\\left(\\\\xi\\\\right)\\$\" for x in (1:size(N,2))'],\n            border = :box,\n            widen = false,\n            linewidth = 2,\n            legend = :outerright,\n            xticks = unique(Ξ),\n            xlabel = \"\\$\\\\xi\\$\",\n            ylabel = \"\\$\\\\operatorname{N}_{i,p}\\\\left(\\\\xi\\\\right)\\$\");\npltR = plot(ξ,R,\n            color = (1:size(R,2))',\n            label = [\"\\$\\\\operatorname{R}_{$x,$p}\" *\n                    \"\\\\left(\\\\xi\\\\right)\\$\" for x in (1:size(R,2))'],\n            border = :box,\n            widen = false,\n            linewidth = 2,\n            legend = :outerright,\n            xticks = unique(Ξ),\n            xlabel = \"\\$\\\\xi\\$\",\n            ylabel = \"\\$\\\\operatorname{R}_{i,p}\\\\left(\\\\xi\\\\right)\\$\");\npltC = plot(P[:,1],P[:,2],\n            border = :box,\n            legend = :outerright,\n            xlabel = \"\\$x\\$\",\n            ylabel = \"\\$y\\$\",\n            linewidth = 2,\n            label = \"\\$\\\\operatorname{P}_{i}\\$\",\n            color = 1:size(P,1),\n            line = (:dot, 1, :grey),\n            marker = (:circle , 5.0, 0.8),\n            markerstrokewidth = 0)\nplot!(C_bsp[:,1],C_bsp[:,2],\n      label = \"\\$\\\\mathbf{C}_{bsp}\\\\left(\\\\xi\\\\right)\\$\",\n      color = 2);\nplot!(C[:,1],C[:,2],\n      label = \"\\$\\\\mathbf{C}\\\\left(\\\\xi\\\\right)\\$\",\n      linewidth = 2,\n      color = 1);\nplot(pltN,pltR,pltC,layout = (3, 1),size = (600, 800))","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"","category":"page"},{"location":"literate/nb_nurbs_1d/","page":"NURBS 1D","title":"NURBS 1D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"EditURL = \"https://github.com/LazyScholar/MagMechFEM_Matlab2Julia/blob/master/docs/literate/ex_NURBStoolbox.jl\"","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox;\nusing Plots;\ndefault(background_color=:transparent, #hide\n        foreground_color=:grey, #hide\n        html_output_format=:svg); #hide\nnothing #hide","category":"page"},{"location":"literate/ex_NURBStoolbox/#NURBS-Toolbox","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"","category":"section"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This notebook will demonstrate some capabilities of the ported NURBS Toolbox by D.M. Spink (Mark Spink (2000)).","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Note that the original Matlab version has not been ported with the same syntax and behaviours.As Julia is a different language with different features. Skim through those examples to get a grasp on the differences if you know the original toolbox.","category":"page"},{"location":"literate/ex_NURBStoolbox/#NURBS-Data-Types","page":"NURBS Toolbox","title":"NURBS Data Types","text":"","category":"section"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This section demonstrates how to construct NURBS data types. And how to identify them.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"To build NURBS structures it is advised to use the function nrbmak() which will accept inputs for surfaces or curves.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"line = nrbmak([0.0 1.5; 0.0 3.0],vec([0.0 0.0 1.0 1.0]))","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"coefs = cat([0.0 0.0; 0.0 1.0],[1.0 1.0; 0.0 1.0],dims=3);\nknots = [vec([0.0 0.0 1.0 1.]),vec([0.0 0.0 1.0 1.0])];\nplane = nrbmak(coefs,knots)","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The fields of the data structures can be accessed similar to Matlab.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"plane.coefs","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Those created data types are typed. And can be therefore used to check for certain types.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"println( typeof(line ) )\nprintln( typeof(plane) )","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The abstract super type NURBS can be used to check for the superset of NURBS.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"println( typeof(line )<:NURBS )\nprintln( typeof(plane)<:NURBS )","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The types NURBS1D and NURBS2D can be used to check for NURBS curves or surfaces.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"println( typeof(line )<:NURBS1D )\nprintln( typeof(plane)<:NURBS1D )\nprintln( typeof(line )<:NURBS2D )\nprintln( typeof(plane)<:NURBS2D )","category":"page"},{"location":"literate/ex_NURBStoolbox/#NURBS-Curves","page":"NURBS Toolbox","title":"NURBS Curves","text":"","category":"section"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"As mentioned creates this toolbox NURBS curves with nrbmak(). This function uses a point matrix (each column a point and each row a coordinate)","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"pnts = [0.5 1.5 4.5 3.0 7.5 6.0 8.5;\n        3.0 5.5 5.5 1.5 1.5 4.0 4.5;\n        0.0 0.0 0.0 0.0 0.0 0.0 0.0];\nnothing #hide","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"and a corresponding knot open knot vector","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"knots = vec([0 0 0 1/4 1/2 3/4 3/4 1 1 1]);\nnothing #hide","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"as input arguments.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"crv = nrbmak(pnts,knots);\nnothing #hide","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Note that this toolbox does works with open NURBS curves!","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This curve can also build by using the test function nrbtestcrv(). To evaluate the curve the function nrbeval() can be used.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"p1 = nrbeval(crv,collect(range(0,1,length=101)),:cartesian)","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The results can be used for plotting or for further evaluation.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"plot(p1[1,:],p1[2,:],\n    border=:box,\n    label=\"crv\",\n    aspect_ratio=:equal,\n    linewidth=2)\nplot!(crv.coefs[1,:],crv.coefs[2,:],\n      linestyle=:dash,\n      markershape =:circle,\n      markerstrokewidth = 0.5,\n      label=\"crv.coefs\",\n      aspect_ratio=:equal)","category":"page"},{"location":"literate/ex_NURBStoolbox/#Surfaces","page":"NURBS Toolbox","title":"Surfaces","text":"","category":"section"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The creation of NURBS surfaces is done similarly to curves. The input for nrbmak has the difference that the points are defined with a 3D Array. The first and second dimension are used equally to the curve for U-direction and the third dimension stores the points in V direction.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Since the process is similar we use a shortcut for creating the data structure.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"srf = nrbtestsrf()","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The evaluation of the surface can also be done with nrbeval().","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"p2 = nrbeval(srf,[collect(range(0,1,length=20)),\n                  collect(range(0,1,length=20))]);\nnothing #hide","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The plotting of that data can be done with one of the many plotting ecosystems.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Plots.pyplot();\nplot(p2[1,:,:],p2[2,:,:],p2[3,:,:],c = :jet,\n     st=:surface,\n     linewidth = 0.5,\n     linecolor = :grey,\n     legend = nothing,\n     camera=[-30,30])\nplot!(srf.coefs[1,:,:],srf.coefs[2,:,:],srf.coefs[3,:,:],\n      linewidth=0.5,\n      st=:wireframe)","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The toolbox does also provide a plot wrapper nrbplot() for the ease of use.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"nrbplot(srf,[10;10],\n        c=:winter,\n        legend = nothing,\n        linewidth=0.5,\n        camera=[-40,60],\n        linecolor = :black)\nϑ = collect(range(0,stop=2*pi,length=180));\nt = cat(cos.(ϑ),sin.(ϑ),dims=2) ./2 .+ 0.5\np3 = nrbeval(srf,permutedims(t,[2,1]));\nplot!(p3[1,:],p3[2,:],p3[3,:] .- 2,linewidth=2)","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Note that this wrapper nrbplot() uses the Plots.pyplot() back end for 3D plots which limits the functionality to that ecosystem. One drawback e.g. is that the depth order/buffer is not considered between chained plot commands. This can be observed in the last plot. The curve is plotted 2 units bellow the surface.","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"","category":"page"},{"location":"literate/ex_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"EditURL = \"https://github.com/LazyScholar/MagMechFEM_Matlab2Julia/blob/master/docs/literate/nb_circular_nurbs.jl\"","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"using MagMechFEM_Matlab2Julia.AHBS;\nusing Plots;\ndefault(background_color=:transparent, #hide\n        foreground_color=:grey, #hide\n        html_output_format=:svg); #hide\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/#Round-NURBS-Structures","page":"NURBS (circular)","title":"Round NURBS Structures","text":"","category":"section"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"These notes were made to understand how circular NURBS structures work. I made only examples for open structures.","category":"page"},{"location":"literate/nb_circular_nurbs/#Plotting-Circles","page":"NURBS (circular)","title":"Plotting Circles","text":"","category":"section"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"Nurbs circle description by Les Piegl, Wayne Tiller (1997) page 299.","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"p = 2;\na = 1/sqrt(2);\nknots = vec([0 0 0 1/4 1/4 1/2 1/2 3/4 3/4 1 1 1]);\npoints = [ 1  0 0; 1  1 0; 0  1 0; -1 1   0; -1 0 0;\n          -1 -1 0; 0 -1 0; 1 -1 0;  1 0 0.0];\nweights = vec([1 a 1 a 1 a 1 a 1]);\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"coords = collect(range(0,1,length=51));\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"C = univariate_NURBS(coords,p,knots,points,weights);\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"plot(C[:,1],C[:,2],\n     label = \"\\$\\\\mathbf{C}\\\\left(\\\\xi\\\\right)\\$\",\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$x\\$\",\n     ylabel = \"\\$y\\$\",\n     aspect_ratio = :equal);\nplot!(points[:,1],points[:,2],\n      label = \"\\$\\\\operatorname{P}_{i}\\$\",\n      color = :green,\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0,\n      series_annotations = text.(string.(1:size(points,1)) .* \" \",\n                                 color = :green,:right))","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"p = 2;\na = cos(30/180*pi);\nknots = vec([0 0 0 1/3 1/3 2/3 2/3 1 1 1]);\npoints = [a 1/2 0; 0 2 0; -a 1/2 0; -2*a -1 0; 0 -1 0; 2*a -1 0; a 1/2 0];\nweights = vec([1 1/2 1 1/2 1 1/2 1]);\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"coords = collect(range(0,1,length=51));\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"C = univariate_NURBS(coords,p,knots,points,weights);\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"plot(C[:,1],C[:,2],\n     label = \"\\$\\\\mathbf{C}\\\\left(\\\\xi\\\\right)\\$\",\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$x\\$\",\n     ylabel = \"\\$y\\$\",\n     aspect_ratio = :equal);\nplot!(points[:,1],points[:,2],\n      label = \"\\$\\\\operatorname{P}_{i}\\$\",\n      color = :green,\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0,\n      series_annotations = text.(string.(1:size(points,1)) .* \" \",\n                                 color = :green,:right))","category":"page"},{"location":"literate/nb_circular_nurbs/#Plotting-Ellipsoid","page":"NURBS (circular)","title":"Plotting Ellipsoid","text":"","category":"section"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"p = [2;2];\nn = [9;5];\nknots = [vec([0 0 0 0.25 0.25 0.5 0.5 0.75 0.75 1 1 1]),\n         vec([0 0 0 0.5 0.5 1 1 1])];\npoints = [\n  -18.0 4.0 -2.0; -18.0 4.0 -2.0; -18.0 4.0 -2.0; -18.0 4.0 -2.0;\n  -18.0 4.0 -2.0; -18.0 4.0 -2.0; -18.0 4.0 -2.0; -18.0 4.0 -2.0;\n  -18.0 4.0 -2.0; -18.0 8.0 -2.0; -18.0 8.0  2.0; -18.0 4.0  2.0;\n  -18.0 0.0  2.0; -18.0   0 -2.0; -18.0   0 -6.0; -18.0 4.0 -6.0;\n  -18.0 8.0 -6.0; -18.0 8.0 -2.0;  -3.0 8.0 -2.0;  -3.0 8.0  2.0;\n   -3.0 4.0  2.0;  -3.0 0.0  2.0;  -3.0   0 -2.0;  -3.0   0 -6.0;\n   -3.0 4.0 -6.0;  -3.0 8.0 -6.0;  -3.0 8.0 -2.0;  12.0 8.0 -2.0;\n   12.0 8.0  2.0;  12.0 4.0  2.0;  12.0 0.0  2.0;  12.0   0 -2.0;\n   12.0   0 -6.0;  12.0 4.0 -6.0;  12.0 8.0 -6.0;  12.0 8.0 -2.0;\n   12.0 4.0 -2.0;  12.0 4.0 -2.0;  12.0 4.0 -2.0;  12.0 4.0 -2.0;\n   12.0 4.0 -2.0;  12.0 4.0 -2.0;  12.0 4.0 -2.0;  12.0 4.0 -2.0;\n   12.0 4.0 -2.0];\ns = sqrt(1/2);\nweights = [  1;   s;   1; s;   1; s; 1; s; 1; s; 0.5; s; 0.5;   s; 0.5;\n             s; 0.5;   s; 1;   s; 1; s; 1; s; 1;   s; 1;   s; 0.5;   s;\n           0.5;   s; 0.5; s; 0.5; s; 1; s; 1; s;   1; s;   1;   s;   1];\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"len = [21;21];\ncoords = cat(repeat(range(0,1,length=len[2]),inner=len[1]),\n             repeat(range(0,1,length=len[1]),outer=len[2]),dims=2);\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"C = bivariate_NURBS( coords, p, knots, points, weights, n);\nnothing #hide","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"Plots.pyplot();\nR = (reshape(C[:,2],(len[1],len[2])) .- minimum(C[:,2])) ./\n    (maximum(C[:,2]) - minimum(C[:,2]))\nplt1 = plot(reshape(C[:,1],(len...)),\n            reshape(C[:,2],(len...)),\n            reshape(C[:,3],(len...)),\n            fill_z=R,\n            legend = nothing,\n            color=:viridis,\n            seriestype=:surface,\n            linecolor = :blue,\n            linewidth=5);\nplot!(reshape(points[:,1],(n...)),\n      reshape(points[:,2],(n...)),\n      reshape(points[:,3],(n...)),\n      st=:wireframe,\n      linewidth=0.5,\n      marker = (:circle , 5.0, 0.8),\n      line = (:dot, 0.5),\n      xlabel = \"\\$x\\$\",\n      ylabel = \"\\$y\\$\",\n      zlabel = \"\\$z\\$\");\nplt2 = heatmap(range(0,1,length=len[2]),\n               range(0,1,length=len[1]), R,\n               legend = nothing,\n               border = :box,\n               color = :viridis,\n               aspect_ratio = :equal,\n               xlabel = \"\\$\\\\xi\\$\",\n               ylabel = \"\\$\\\\eta\\$\",\n               widen = false);\nplot(plt2,plt1,layout=(1,2))","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"","category":"page"},{"location":"literate/nb_circular_nurbs/","page":"NURBS (circular)","title":"NURBS (circular)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"notes/#Collection-of-random-Notes-and-Examples","page":"Overview","title":"Collection of random Notes and Examples","text":"","category":"section"},{"location":"notes/","page":"Overview","title":"Overview","text":"Notebook Summary\nBernstein Polynomials Notes on Bernstein Polynomials and its derivatives.\nB-Splines Notes on B-Splines and its basis functions.\nNURBS 1D Notes on NURBS.\nCircular NURBS Structures Notes on open circular NURBS structures.\nNUBRS 1D Bézier Extraction Notes on the calculation of NURBS via Bézier extraction.","category":"page"},{"location":"doc_AHBS/#Documentation:-Adaptive-HBS","page":"AHBS","title":"Documentation: Adaptive HBS","text":"","category":"section"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"CurrentModule = MagMechFEM_Matlab2Julia.AHBS","category":"page"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"Pages = [\"doc_AHBS.md\"]\nDepth = 2","category":"page"},{"location":"doc_AHBS/#Module","page":"AHBS","title":"Module","text":"","category":"section"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"<style>\n#horlist ul {\ndisplay: grid;\ngrid-template-columns: repeat(auto-fit, minmax(25ch, 1fr));\ngrid-gap: 4px;\nlist-style: none;\n}\n</style>\n<div id=\"horlist\">","category":"page"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"AHBS","category":"page"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS","text":"AHBS\n\nAdaptive Hierarchical B-Spline module. Contains some functions and programs implemented for sparse adaptive hierarchical NURBS support and further manipulation.\n\ninfo: Note:\nThe Matlab version had import functions for NURBS from Rhino3D and some related UI processing tools. I did not port those as the UI capabilities of Julia are still not stable enough (imo) and the Rhino3D integration is not of importance for this port.\n\nExports\n\nbernsteinBasis3D\nbernstein_base1D\nbivariate_NURBS\ncalculate_knot_span\ndegree_elev_1D\nget_bezier_extraction_ij\nknot_mult_var\nknots_subd_bez\noslo1_global\ntrivariate_NURBS\nunivariate_NURBS\n\nImports\n\nBase\nCore\nDocStringExtensions\nLinearAlgebra\nSparseArrays\n\n\n\n\n\n","category":"module"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"</div>","category":"page"},{"location":"doc_AHBS/#Functions-and-Methods","page":"AHBS","title":"Functions and Methods","text":"","category":"section"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"bernstein_base1D\nbernsteinBasis3D\nunivariate_NURBS\nbivariate_NURBS\ntrivariate_NURBS\noslo1_global","category":"page"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.bernstein_base1D","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.bernstein_base1D","text":"bernstein_base1D(p::I,ξ::Vector{F},nd::I=0\n                ) where {I<:Integer,F<:AbstractFloat}\n\nAlgorithm to compute the p+1 bernstein poylnomials and Derivatives. The function is based based on Les Piegl, Wayne Tiller (1997).\n\nArguments:\n\np: polynomial degree of bernstein polynomials\nξ: evaluation positions (from -1 to 1)\nnd: return derivatives up to d^nb/dξ^nb (defaults to 0)\n\nOutput:\n\nB: the p+1 bernstein polynomials evaluated at ξ, each column stores one polynomial\ndB: the first derivative of the bernstein polynomials evaluated at ξ, each row stores one polynomial (returned only if nb >= 1)\nddB: the second derivative of the bernstein polynomials evaluated at ξ, each row stores one polynomial (returned only if nb>=2)\n...: and so on ... (up to p derivatives can be requested (nd<=p))\n\nExamples:\n\njulia> B, dB, ddB, dddB = bernstein_base1D( 3, ξ, 3)\njulia> B, dB = bernstein_base1D( 3, ξ, 1)\njulia> B = bernstein_base1D( 5, ξ)\n\nReference:\n\nAlgorithm based on 'The NURBS BOOK' pg20 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.bernsteinBasis3D","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.bernsteinBasis3D","text":"bernsteinBasis3D(p::I, q::I, r::I,\n                 ξ::Vector{F}, η::Vector{F}, ψ::Vector{F},\n                 nd::I=0\n                ) where {I<:Integer,F<:AbstractFloat}\n\nThis function calculates the trivariate bernstein base functions on the area ξ,η,ψ in [-1,+1]. It uses the operator kron to save calculation time. Therefore the univariate base components of that base will be computed first. This method of computation requires that the ξ,η and ψ values are univariate (have no duplicates) as the mesh will be formed automatically by kron(*,kron(*,*)).\n\nArguments:\n\np: polynomial degree of bernstein polynomials in ξ\nq: polynomial degree of bernstein polynomials in η\nr: polynomial degree of bernstein polynomials in ψ\nξ: evaluation positions (from -1 to 1) of first direction\nη: evaluation positions (from -1 to 1) of second direction\nψ: evaluation positions (from -1 to 1) of third direction\nnd: return derivatives up to d^nb/dX^nb (defaults to 0) (only implemented up to nd=2)\n\nOutput:\n\nB: the p+1 bernstein polynomials evaluated at the mesh of ξ,η and ψ, each column stores one polynomial in a linearised way\ndB: the first derivatives of the bernstein polynomials, each row stores one derivative and each column one polynomial (the polynomials extend into the third array dimension in a linearised way) (returned only if nb >= 1)\nddB: the second derivatives of the bernstein polynomials evaluated at ξ, each row stores one derivative and each column one polynomial (the polynomials extend into the third array dimension in a linearised way) (returned only if nb >= 2)\n\nExamples:\n\njulia> B, dB, ddB = bernsteinBasis3D( 3, 2 , 4, ξ, η, ψ, 2)\njulia> B, dB = bernsteinBasis3D( 3, 2, 4, ξ, η, ψ, 1)\njulia> B = bernsteinBasis3D( 3, 2, 1, ξ, η, ψ)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.univariate_NURBS","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.univariate_NURBS","text":"univariate_NURBS(coords::Vector{F},\n                 p::I,\n                 knots::Vector{F},\n                 points::Matrix{F},\n                 weights::Vector{F}\n                ) where {I<:Integer,F<:AbstractFloat}\n\nCalculates the points of a univariate NURBS geometry. The function is based on the B-Spline algorithm of de Boor Carl Boor (1972).\n\nArguments:\n\ncoords: vector containing the parametric evaluation points\np: polynomial degree\nknots: knot tuple\npoints: point matrix of all unweighted control points each column belongs to one coordinate\nweights: weight vector for the points\nn: number of points\n\nOutput:\n\nC: calculated point coordinates belonging to each coordinate\n\nExamples:\n\njulia> C = univariate_NURBS( coords, p, knots, points, weights)\n\nReference:\n\nAlgorithm based on 'On Calculating with B-Splines' from Carl Boor (1972)\nFurther references: Les Piegl, Wayne Tiller (1997) and Mark Spink (2000)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.bivariate_NURBS","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.bivariate_NURBS","text":"bivariate_NURBS(coords::Matrix{F},\n                p::Vector{I},\n                knots::Vector{Vector{F}},\n                points::Matrix{F},\n                weights::Vector{F},\n                n::Vector{I}\n               ) where {I<:Integer,F<:AbstractFloat}\n\nCalculates the points of a bivariate NURBS geometry. The function is based on the B-Spline algorithm of de Boor Carl Boor (1972).\n\nArguments:\n\ncoords: matrix containing the parametric evaluation pairs so each i-th row contains the evaluation point [xi[i] eta[i]]\np: vector of the directional polynomial degrees\nknots: vector of directional knot tuples\npoints: linearised point matrix of all unweighted control points each column belongs to one coordinate\nweights: weight vector for the points\nn: number of points for each direction\n\nOutput:\n\nC: calculated point coordinates belonging to each coordinate row\n\nExamples:\n\njulia> C = bivariate_NURBS( coords, p, knots, points, weights, n)\n\nReference:\n\nAlgorithm based on 'On Calculating with B-Splines' from Carl Boor (1972)\nFurther references: Les Piegl, Wayne Tiller (1997) and Mark Spink (2000)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.trivariate_NURBS","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.trivariate_NURBS","text":"trivariate_NURBS(coords::Matrix{F},\n                 p::Vector{I},\n                 knots::Vector{Vector{F}},\n                 points::Matrix{F},\n                 weights::Vector{F},\n                 n::Vector{I}\n                ) where {I<:Integer,F<:AbstractFloat}\n\nCalculates the points of a trivariate NURBS geometry. The function is based on the B-Spline algorithm of de Boor Carl Boor (1972).\n\nArguments:\n\ncoords: matrix containing the parametric evaluation pairs so each i-th row contains the evaluation point [xi[i] eta[i] psi[i]]\np: vector of the directional polynomial degrees\nknots: vector of directional knot tuples\npoints: linearised point matrix of all unweighted control points each column belongs to one coordinate\nweights: weight vector for the points\nn: number of points for each direction\n\nOutput:\n\nC: calculated point coordinates belonging to each coordinate row\n\nExamples:\n\njulia> C = trivariate_NURBS( coords, p, knots, points, weights, n)\n\nReference:\n\nAlgorithm based on 'On Calculating with B-Splines' from Carl Boor (1972)\nFurther references: Les Piegl, Wayne Tiller (1997) and Mark Spink (2000)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.oslo1_global","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.oslo1_global","text":"oslo1_global(p::I,knots_old::Vector{F},knots_new::Vector{F}\n            ) where {I<:Integer,F<:AbstractFloat}\n\nCompute the global subdivision matrix for the B-spline bases belonging to the knot vectors knotsold and knotsnew.\n\nArguments:\n\np: polynomial degree of both spline bases\nknots_old: old/coarse knot vector\nknots_new: knots to insert (values include the old knot vector)\n\nOutput:\n\nM: sparse subdivision matrix\n\nExamples:\n\njulia> M = oslo1_global( p, knots_old, knots_new)\n\nAlgorithm based on:\n\nDiscrete B-splines and subdivision techniques in computer-aided geometric design and computer graphics, from Elaine Cohen, Tom Lyche, Richard Riesenfeld (1980)\nA short proof of the Oslo algorithm, from Hartmut Prautzsch (1984)\nMaking the OSLO Algorithm More Efficient, from T. Lyche, K. Mørken (1986)\nMulti-level Bézier extraction for hierarchical local refinement of Isogeometric Analysis, from Davide D'Angella, Stefan Kollmannsberger, Ernst Rank, Alessandro Reali (2018)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#Utility-Functions-and-Methods","page":"AHBS","title":"Utility Functions and Methods","text":"","category":"section"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"knot_mult_var\nknots_subd_bez\nget_bezier_extraction_ij\ncalculate_knot_span\ndegree_elev_1D","category":"page"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.knot_mult_var","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.knot_mult_var","text":"knot_mult_var(p::I,knots::Vector{F}) where {I<:Integer,F<:AbstractFloat}\n\nHelper function knot_mult for the bs2bs-algorithm. This function computes and returns the unique knots and the multiplicity of all those knots between the first and last knot of multiplicity p+1 it returns additionally the count of those unique knots.\n\nArguments:\n\np: polynomial degree for the knot vector\nknots: knot vector\n\nOutput:\n\nmultiplicity: vector indicating the occurrence of the knots returned in vector unique_knots the first and last entry will be 1, ignoring the p+1 multiplicity\nunique_knots: vector containing the unique knot values\nknot_count: integer indicating the count of the knot entries without multiplicity\n\nExamples:\n\njulia> multiplicity, unique_knots, knot_count = knot_mult_var( p, knots)\n\nReference:\n\nAlgorithm based on Giulio Casciola, Lucia Romani (2007)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.knots_subd_bez","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.knots_subd_bez","text":"knots_subd_bez(p::I,knots_old::Vector{F}\n              ) where {I<:Integer,F<:AbstractFloat}\n\nHelper function to subdivide one knot vector. It will return the subdivided knot vector, the corresponding bezier knots and the associated bezier start point matrix.\n\nArguments:\n\np: spline degree of spline base\nknots_old: knot vector to subdivide\n\nOutput:\n\nknots_subdiv: subdivided knot vector\nknots_bezier: bezier knot vector of the subdivided knot vector\nbezier_ij: bezier extraction start point matrix associated with the created knot vector\n\nExamples:\n\njulia> knots_subdiv, knots_bezier, bezier_ij = knots_subd_bez( p, knots_old)\n\nReference:\n\nAlgorithm based on Giulio Casciola, Lucia Romani (2007)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.get_bezier_extraction_ij","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.get_bezier_extraction_ij","text":"get_bezier_extraction_ij(p::I,knots::Vector{F}\n                        ) where {I<:Integer,F<:AbstractFloat}\n\nThis function calculates the start indices of the bezier extraction patches. It is a variation of some part of the bs2bs-algorithm. And could be replaced by it.\n\nArguments:\n\np: spline degree of spline base\nknots: knot vector to subdivide\n\nOutput:\n\nbezier_ij: bezier extraction start point indices\n\nExamples:\n\njulia> bezier_ij = get_bezier_extraction_ij( p, knots)\n\nReference:\n\nAlgorithm based on Giulio Casciola, Lucia Romani (2007)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.calculate_knot_span","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.calculate_knot_span","text":"calculate_knot_span(p::I,knots::Vector{F},coords::Vector{F}\n                   ) where {I<:Integer,F<:AbstractFloat}\n\nComputes the knot span for a vector of evaluation points on a knot tuple.\n\nArguments:\n\np: polynomial degree for the knot vector\nknots: knot vector\ncoords: evaluation parameter vector\n\nOutput:\n\nknot_span: knot span of each parametric evaluation point of coords\n\nExamples:\n\njulia> knot_span = calculate_knot_span( p, knots, coord)\n\nReference:\n\nsee also: univariate_NURBS, bivariate_NURBS and trivariate_NURBS\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#MagMechFEM_Matlab2Julia.AHBS.degree_elev_1D","page":"AHBS","title":"MagMechFEM_Matlab2Julia.AHBS.degree_elev_1D","text":"degree_elev_1D(p::I,\n               t::I,\n               knots::Vector{F},\n              ) where {I<:Integer,F<:AbstractFloat}\n\nThe function is based on on the algorithm A5.9 in Les Piegl, Wayne Tiller (1997). The function computes the the degree elevation matrix to elevate one open B-Spline t times. The function computes also the new knot vector. The function is not optimized for speed nor memory consumption.\n\nArguments:\n\np: polynomial degree\nt: elevate the polynomial degree t times\nknots: unchanged knot tuple\n\nOutput:\n\nM_elev: degree elevation matrix\nknots_elev: new knot vector\n\nExamples:\n\njulia> M_elev, knots_elev = degree_elev_1D(p, t, knots)\n\nReference:\n\nAlgorithm based on 'The NURBS Book' from Les Piegl, Wayne Tiller (1997)\nFurther references: Mark Spink (2000)\n\n\n\n\n\n","category":"function"},{"location":"doc_AHBS/#Index","page":"AHBS","title":"Index","text":"","category":"section"},{"location":"doc_AHBS/","page":"AHBS","title":"AHBS","text":"Pages = [\"doc_AHBS.md\"]","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"EditURL = \"https://github.com/LazyScholar/MagMechFEM_Matlab2Julia/blob/master/docs/literate/nb_b_splines.jl\"","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"using Plots;\ndefault(background_color=:transparent, #hide\n        foreground_color=:grey, #hide\n        html_output_format=:svg); #hide\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/#B-Splines","page":"B-Splines","title":"B-Splines","text":"","category":"section"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"These notes are partially based on the NURBS Book from Les Piegl, Wayne Tiller (1997).","category":"page"},{"location":"literate/nb_b_splines/#B-Spline-Base-Functions","page":"B-Splines","title":"B-Spline Base Functions","text":"","category":"section"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"B-Spline Base Functions operatornameN_ipleft(xiright) recursively definead as","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"operatornameN_ipleft(xiright) =\nbegincases\nbegincases\n1  text if  xi_i leq xi  xi_i+1 \n0  text else \nendcases  text if  p=0 \nfracxi-xi_ixi_i+p-xi_i \noperatornameN_ip-1left(xiright) +\nfracxi_i+p+1-xixi_i+p+1-xi_i+1 \noperatornameN_i+1p-1left(xiright)  text if  p  0\nendcases\nquad forall quad xiinleftxi_1xi_n+p+1right_mathbbR","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"according to Les Piegl, Wayne Tiller (1997) (definition 2.5 on page 50) (the fractions are defined to be zero if the divisor is zeros). The knots xi_i in this formula are defined inside the knot  vector mathbfXi = left(xi_1dotsxi_idotsxi_n+p+1right) (with xi_igeqxi_i-1 and therefore also named knot tuple mathbfXi). The recursive function, the knots of mathbfXi in combination with the polynomial degree p are sufficient to construct the iinleft1nright_mathbbZ base functions operatornameN_ipleft(xiright).","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"p = 2;\nΞ = vec([0 1 2 3.5 4 5 5 6]);\nξ = collect(range(Ξ[1],Ξ[end],length=61));\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"function bspline_bf1(p::Integer,Ξ::Vector{typeof(1.0)},ξ::Vector{typeof(1.0)})\nn0 = length(Ξ)-1;\nN = zeros(typeof(1.0),(length(ξ),n0));\nN[(ξ .>= Ξ[1:n0]') .& (ξ .< Ξ[2:n0+1]')] .= 1.0;\nN[end , ξ[end] .<= Ξ[2:n0+1]] .= 1.0; # just to have it look nice\nfor k in 1:p\n  for i in 1:n0-k\n    temp_1 = (Ξ[i+k] - Ξ[i]);\n    temp_2 = (Ξ[i+k+1] - Ξ[i+1]);\n    if temp_1 != 0;\n      temp_1 = (ξ .- Ξ[i]) ./ temp_1;\n    else\n      temp_1 = zeros(typeof(1.0),length(ξ));\n    end # if\n    if temp_2 != 0;\n      temp_2 = (Ξ[i+k+1] .- ξ) ./ temp_2;\n    else\n      temp_2 = zeros(typeof(1.0),length(ξ));\n    end # if\n    N[:,i] .= temp_1 .* N[:,i] .+ temp_2 .* N[:,i+1];\n  end # for i\nend # for k\nreturn N[:,1:n0-p];\nend # bspline_bf1\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"N = bspline_bf1(p,Ξ,ξ);\nplot(ξ,N,\n     label = [\"\\$\\\\operatorname{N}_{$x,$p}\" *\n              \"\\\\left(\\\\xi\\\\right)\\$\" for x in (1:length(Ξ)-1-p)'],\n     color = (1:length(Ξ)-1-p)',\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$\\\\xi\\$\",\n     ylabel = \"\\$\\\\operatorname{N}_{i,p}\\\\left(\\\\xi\\\\right)\\$\",\n     widen = false);\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"The occurrence and spacing of the knots xi in the tuple mathbfXi. Characterize the final form of the Base Functions operatornameN_ipleft(xiright). And can therefore used to omit the branching in the formula similar to the Bernstein Polynomials (the divisors are sometimes zero). Which could be used to vectorize the recursive calculation (only useful for huge problems).","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"function bspline_bf2(p::Integer,Ξ::Vector{typeof(1.0)},ξ::Vector{typeof(1.0)})\nn0 = length(Ξ)-1;\nN = zeros(typeof(1.0),(length(ξ),n0));\nN[(ξ .>= Ξ[1:n0]') .& (ξ .< Ξ[2:n0+1]')] .= 1.0;\nN[end , ξ[end] .<= Ξ[2:n0+1]] .= 1.0;  # just to have it look nice\ntemp_1 = BitVector(fill(false,n0+1));\ntemp_2 = BitVector([Ξ[1:n0] .!= Ξ[2:n0+1];false]);\nfor k in 1:p\n  n = n0-k;\n  temp_1[1:n0] .= temp_2[1:n0];\n  temp_1[n+1] = false;\n  temp_2[1] = false;\n  temp_N = (Ξ[temp_2 >> k]' .- ξ) ./ (Ξ[temp_2 >> k] .- Ξ[temp_2])' .*\n           N[:,temp_2[1:n0]];\n  N[:,temp_1[1:n0]] .*= (ξ .- Ξ[temp_1]') ./ (Ξ[temp_1 >> k] .- Ξ[temp_1])';\n  N[:,temp_2[1:n0] << 1] .+= temp_N;\n  temp_2 .|= (temp_2 << 1);\n  temp_2[n+1] = false;\nend # for k\nreturn N[:,1:n0-p];\nend # bspline_bf2\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"plot!(ξ,bspline_bf2(p,Ξ,ξ),\n      label = [\"\\$\\\\operatorname{N}_{$x,$p}\" *\n               \"\\\\left(\\\\xi\\\\right)\\$\" for x in (1:length(Ξ)-1-p)'],\n      color = (1:length(Ξ)-1-p)',\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0)","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"For further details and properties on B-Splines see the NURBS Book from Les Piegl, Wayne Tiller (1997).","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"The further notes are only done with open (synonymous for non-periodic or clamped) B-Splines which are characterized by p+1 equal knot entries at the start and end of their  knot tuple mathbfXi.","category":"page"},{"location":"literate/nb_b_splines/#B-Splines-2","page":"B-Splines","title":"B-Splines","text":"","category":"section"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"B-Splines are characterized via knot vector mathbfXi, polynomial or spline degree p and their control points mathbfP. Those control points P_i of the same arbitrary dimension (e.g. P_i = left(P_ixP_iyright) for 2 dimensional curves or P_i = left(P_ixP_iyP_iyright) for 3 dimensional ones). For the ease of use they can be stored in point matrices/vectors e.g.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfP=\nleftbeginarrayc\nP_1crvdotscr P_icrvdotscr P_n\nendarrayright =\nleftbeginarrayccc\nP_1x  P_1y  P_1zcr\nvdots  vdots  vdotscr\nP_ix  P_iy  P_izcr\nvdots  vdots  vdotscr\nP_nx  P_ny  P_nz\nendarrayright","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"which length n has to match with the number of base functions which in turn gets defined by the length of the knot vector n+p+1.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"p = 2;\nΞ = vec([0 0 0 1 1 2 3.5 4 4 4]);\nξ = collect(range(Ξ[1],Ξ[end],length=61));\nP = [-4 -3 -1 0 1 2 4;\n      0  1  8 2 7 1 8;\n      0  0  0 0 0 0 0]'.*1.0;\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"And the base functions operatornameN_ipleft(xiright) are structured in a horizontal array","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfNleft(xiright) = left beginarrayccccc\noperatornameN_1pleft(xiright)  cdots \noperatornameN_ipleft(xiright)  cdots \noperatornameN_npleft(xiright)endarray right","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"where each operatornameN_ipleft(xiright) could be seen as a vertical vector after evaluation.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"N = bspline_bf2(p,Ξ,ξ);\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"This makes it convenient to write the definition of the B-Splines","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfCleft(xiright) =\nsum_i=1^noperatornameN_ipleft(xiright)P_i","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"as einstein sum convention","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfCleft(xiright) =\noperatornameN_ipleft(xiright)P_i","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"or simply as matrix multiplication","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfC = mathbfNmathbfP","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"(the arguments xi are omitted for a leaner definition).","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"C = N * P;\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"plot(ξ,N,\n     label = [\"\\$\\\\operatorname{N}_{$x,$p}\" *\n              \"\\\\left(\\\\xi\\\\right)\\$\" for x in (1:length(Ξ)-1-p)'],\n     color = (1:length(Ξ)-1-p)',\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$\\\\xi\\$\",\n     ylabel = \"\\$\\\\operatorname{N}_{i,p}\\\\left(\\\\xi\\\\right)\\$\",\n     widen = false)\n\nplot(C[:,1],C[:,2],\n     label = \"\\$\\\\mathbf{C}\\\\left(\\\\xi\\\\right)\\$\",\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$x\\$\",\n     ylabel = \"\\$y\\$\",\n     aspect_ratio = :equal);\nplot!(P[:,1],P[:,2],\n      label = \"\\$\\\\operatorname{P}_{i}\\$\",\n      color = :green,\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0)","category":"page"},{"location":"literate/nb_b_splines/#The-'de-Boor-Recursion'","page":"B-Splines","title":"The 'de Boor Recursion'","text":"","category":"section"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"Carl de Boor postulated 1970 a algorithm to calculate the B-Splines directly without calculating the base functions (see Carl Boor (1972)). This quite efficient algorithm uses the characteristics of the recursive formula (the base functions are on certain areas zero and the divisors too). And avoids useless calculation. The resulting calculation is quite similar to the construction of the bernstein/bézier splines.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"For completeness here the derivation.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfCleft(xiright) =\nsum_i=1^noperatornameN_ipleft(xiright)P_i","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"Each paramteric value xi of the curve lies between two neighboring knots xi_kleqxi  xi_k+1. And on this range are only p+1 base functions non zero.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"xi_k leq xi  xi_k+1 Rightarrow\ntext support  left operatornameN_k-ppleft(xiright) dots \noperatornameN_kpleft(xiright) right text other \noperatornameN_ipleft(xiright) text zero","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"Therefore one can define a point on the spline for one specific xi as","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"beginaligned\nmathbfCleft(xiright)\n=\nsum_i=k-p^kleft fracxi - xi_ixi_i+p - xi_i\noperatornameN_ip-1left(xiright) P_i right  +\nsum_i=k-p^kleft fracxi_i+p+1 - xixi_i+p+1 - xi_i+1\noperatornameN_i+1p-1left(xiright)  P_i right\n\n=\nsum_i=k-p^kleft fracxi - xi_ixi_i+p - xi_i\noperatornameN_ip-1left(xiright)  P_i right  +\nsum_i=k-p+1^k+1left fracxi_i+p - xixi_i+p - xi_i\noperatornameN_ip-1left(xiright)  P_i-1 right\nendaligned","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"and with the knowledge that","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"xi_k  leq xi  xi_k+1 Rightarrow\ntext support   left operatornameN_k-p+1p-1left(xiright)\ndots operatornameN_kp-1left(xiright) right text other \noperatornameN_ip-1left(xiright) text zero","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"we can combine the sums into one sum.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfCleft(xiright) =\nsum_i=k-p+1^kleft left( fracxi - xi_ixi_i+p - xi_i\nP_i + fracxi_i+p - xixi_i+p - xi_i P_i-1 right)\noperatornameN_ip-1left(xiright) right ","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"Those considerations can be redone recursively to the lowest level and with the start condition operatornameN_i0left(xiright)=1  forall  xi_k  leq xi  xi_k+1 follows","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"mathbfC^j_ileft(xiright) =\nbegincases\nP_i  text for  j = 0 \nleft(1-alpha^j_ileft(xiright)right)\nmathbfC^j-1_i-1left(xiright) +\nalpha^j_ileft(xiright) mathbfC^j-1_ileft(xiright) \ntext for  j  0\nendcases quad  quad alpha^j_ileft(xiright) =\nfracxi - xi_ixi_i+p-j+1 - xi_i","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"which is the recursive definition of the B-Spline for one specific xi.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"function bspline_deBoor(p::Integer,Ξ::Vector{typeof(1.0)},\n                        ξ::Vector{typeof(1.0)},P::Matrix{typeof(1.0)})\nknot_span = (Ξ[1:end-1]' .<= ξ) .& (ξ .< Ξ[2:end]');\ntemp = vec(.~any(knot_span, dims=2));\nif any(temp)\n  knot_span[temp,:] .= (ξ[temp] .== Ξ[2:end]') .& (ξ[temp] .> Ξ[1:end-1]');\nend # if\nknot_span = findfirst.(eachrow(knot_span));\ntemp_P = zeros(eltype(P),(length(ξ),size(P,2),p+1));\nfor k in 0:p\n  temp_P[:,:,k+1] = P[knot_span .- k,:];\nend # for k\nα = zeros(eltype(ξ),length(ξ));\nidx = zeros(typeof(1),length(ξ));\nfor j in 1:p\n  for i in 1:p-j+1\n    idx .= knot_span .+ (1-i);\n    α .= (ξ .- Ξ[idx]) ./ (Ξ[idx .+ (p-j+1)] .- Ξ[idx]);\n    temp_P[:,:,i] = temp_P[:,:,i+1] .* (1 .- α) .+ temp_P[:,:,i  ] .* α;\n  end # for i\nend # for j\nreturn temp_P[:,:,1];\nend # bspline_deBoor\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"C = bspline_deBoor(p,Ξ,ξ,P);\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"plot(C[:,1],C[:,2],\n     label = \"\\$\\\\mathbf{C}\\\\left(\\\\xi\\\\right)\\$\",\n     border = :box,\n     linewidth = 2,\n     legend = :outerright,\n     xlabel = \"\\$x\\$\",\n     ylabel = \"\\$y\\$\",\n     aspect_ratio = :equal);\nplot!(P[:,1],P[:,2],\n      label = \"\\$\\\\operatorname{P}_{i}\\$\",\n      color = :green,\n      line = (:dot, 2),\n      marker = (:circle , 5.0, 0.8),\n      markerstrokewidth = 0)","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"The following code and the animation show the relationship between the bézier and the B-Splines. And shows how the de Boor algorithm works.","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"N = bspline_bf2(p,Ξ,ξ); #hide\nPlots.gr(); #hide\nPlots.reset_defaults();\nanimation = @animate for s in 1:length(ξ)\nplt1 = plot(ξ,N,\n            color = (1:size(P,1))',\n            linewidth = 1,\n            legend = :none,\n            border = :none,\n            widen = false);\nplot!([ξ[s];ξ[s]],[0.0,1.0],color = :red);\n\nplt2 = plot(C[1:s,1],C[1:s,2],\n            border = :none,\n            line = (:dot, 2),\n            color = :grey,\n            legend = :none,\n            aspect_ratio = :equal);\nscatter!(P[:,1],P[:,2],\n         color = 1:size(P,1),\n         markerstrokewidth = 0);\n\nif ξ[s] != Ξ[end]\n  k = findfirst((Ξ[1:end-1] .<= ξ[s]) .& (ξ[s] .< Ξ[2:end]));\nelse\n  k = length(Ξ)-p-1;\nend\ntemp_P = reverse(P[k-p:k,:],dims=1);\nplot!(temp_P[:,1],temp_P[:,2]);\nfor j in 1:p\n  for i in 1:p-j+1\n    idx = k + (1-i);\n    α = (ξ[s] - Ξ[idx]) / (Ξ[idx + (p-j+1)] - Ξ[idx]);\n    temp_P[i,:] .= temp_P[i+1,:] .* (1 - α) .+ temp_P[i,:] .* α;\n  end # for i\n  temp_P = temp_P[1:end-1,:];\n  plot!(temp_P[:,1],temp_P[:,2],marker = :circle);\nend # for j\nplot(plt1,plt2,layout = grid(2, 1, heights=[0.2 ,0.8]),size = (600, 700))\nend\ngif(animation, \"animation_deBoor.gif\", fps = 10)","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"Plots.pyplot(); #hide\nnothing #hide","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"","category":"page"},{"location":"literate/nb_b_splines/","page":"B-Splines","title":"B-Splines","text":"This page was generated using Literate.jl.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"EditURL = \"https://github.com/LazyScholar/MagMechFEM_Matlab2Julia/blob/master/docs/literate/nb_nurbs_1d_bezier.jl\"","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"using MagMechFEM_Matlab2Julia.AHBS;\nusing Plots;\ndefault(border = :box,\n        background_color=:transparent, #hide\n        foreground_color=:grey, #hide\n        html_output_format=:svg, #hide\n        linewidth = 2,\n        legend = :outerright,\n        widen = false);\nnothing #hide","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/#D-NURBS-by-Bézier-extraction","page":"NUBRS 1D Bézier Extraction","title":"1D NURBS by Bézier extraction","text":"","category":"section"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"These notes are partially based on the NURBS Book from Les Piegl, Wayne Tiller (1997) and the article of Michael J. Borden, Michael A. Scott, John A. Evans, Thomas J. R. Hughes (2010).","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"p = 2;\nΞ = vec([0.0 0 0 1 1 2 3.5 4 4 4]);\nP = [-4 -3 -1 0 1 2 4;\n      0  1  8 2 7 1 8;\n      0  0  0 0 0 0 0]'/8;\nweights = vec([1 1 1 1 1 1/4 1]);\nξ = collect(range(Ξ[1],Ξ[end],length=61));\nnothing #hide","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/#B-Splines-by-Bézier-extraction","page":"NUBRS 1D Bézier Extraction","title":"B-Splines by Bézier extraction","text":"","category":"section"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"A Bézier Spline is a special case of a B-Spline (only start and end knots with multiplicity of p+1). Therefore the p+1 Bézier/Bernstein Base functions","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"operatornameB_ipleft(overlinexiright) =\nfracpi left(p-iright) frac12^p\nleft(overlinexi+1right)^i left(1-overlinexiright)^p-i\nquad forall quad overlinexiinleft-11right_mathbbR   \niinleft0pright_mathbbZ","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"can be used to define the B-Spline base functions.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"n = 11;\nξ_B = collect(range(-1,1,length=n));\nB = bernstein_base1D(p,ξ_B);\nplot(ξ_B,B,\n     label = [\"\\$\\\\operatorname{B}_{$x,$p}\" *\n              \"\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\" for x in (0:p)'],\n     color = (1:p+1)',\n     xlabel = \"\\$\\\\overline{\\\\xi}\\$\",\n     ylabel = \"\\$\\\\operatorname{B}_{i,p}\\\\left(\\\\overline{\\\\xi}\\\\right)\\$\")","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"For other cases with arbitrary knot tuples mathbfXi it is also possible to use Bézier Polynomials as the base of calculation.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"The basic idea is that by increasing the multiplicity of each knot xi_i to at least p (by knot insertion) the B-Spline base functions will be bézier base functions for each space betewwn unique knots.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"To faciliate the further explanation I will call the initial base mathbfN^mathrmCleft(xiright) with the arbitrary knot tuple mathbfXi^mathrmC the coarse B-Spline base with coarse base functions operatornameN^mathrmC_ipleft(xiright). And the one with the increased multiplicity bézier or bernstein base with the superscript mathrmB.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"And the basic rule used here is that each coarser base mathbfN^mathrmCleft(xiright) is a linear combination of its finer base mathbfN^mathrmBleft(xiright) is. So one could write","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"mathbfN^mathrmCleft(xiright) =\nmathbfM^mathrmCmathrmB  mathbfN^mathrmBleft(\nxiright)","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"where mathbfM^mathrmCmathrmB is a subdivision matrix which can be computed by several methods (see knot insertion or subdivision of B-Splines) like the oslo algorithm (Elaine Cohen, Tom Lyche, Richard Riesenfeld (1980)).","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"Ξ_B = [Ξ[1]; repeat(unique(Ξ),inner=p); Ξ[end]];\nprintln(Ξ  );\nprintln(Ξ_B);\nM_B = oslo1_global(p,Ξ,Ξ_B)","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"So we can calculate the p+1 base functions between two unique knots by using a linear combination of bernstein polynomials of the degree p.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"I will name those spaces beween those unique knots 'elements'. And define a helper function operatornamekleft(eright) rightarrow i which gives me the smallest index of the base functions operatornameN_ipleft(xiright) which are not zero on this space/element e.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"bezier_ij = get_bezier_extraction_ij(p,Ξ)","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"A second helper function operatornamef^eleft(xiright) = 2frac xi-xi_operatornamek^mathrmCleft(eright)+pxi_ operatornamek^mathrmCleft(eright)+p+1 - xi_operatornamek^mathrmCleft(eright)+p - 1 serves the purpose to map the definition area of the element xiinleftxi_operatornamek^mathrmCleft(eright)+p  xi_ operatornamek^mathrmCleft(eright)+p+1 right_mathbbR =Omega_e to the definition area of the bernstein polynomials overlinexiinleft -1 1right_mathbbR.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"With this we can write the calculation rule for the p+1 base functions operatornameN^mathrmC_ipleft(xiright) on each element/section e of a B-Spline as","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"operatornameN^mathrmC_operatornamek^mathrmCleft(eright)\n+ipleft(xiright) = sum_j=0^p M^mathrmCmathrmB_\noperatornamek^mathrmCleft(eright)+ioperatornamek^\nmathrmBleft(eright)+j  operatornameB_jpleft(\noperatornamef^mathrmCeleft(xiright) right) \nquad forall quad xiinleftxi_ operatornamek^mathrmC\nleft(eright)+p   xi_ operatornamek^mathrmCleft(eright)\n+p+1 right_mathbbR\n   iinleft0pright_mathbbZ","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"where the values M^mathrmCmathrmB_operatornamek^mathrmC left(eright)+ioperatornamek^mathrmBleft(eright)+j for ijinleft0pright_mathbbZ can be summarized into a sub matrix mathbfM^mathrmCmathrmBe of mathbfM^mathrmCmathrmB. This matrix mathbfM^mathrmCmathrmBe is also called bézier extraction operator. By furthermore defining a localized subarray","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"mathbfN^mathrmCeleft(xiright) = left beginarrayccccc\noperatornameN^mathrmC_operatornamek^mathrmCleft(eright)+0\npleft(xiright)  cdots \noperatornameN^mathrmC_operatornamek^mathrmCleft(eright)+i\npleft(xiright)  cdots \noperatornameN^mathrmC_operatornamek^mathrmCleft(eright)+p\npleft(xiright)endarray right\nquad forall quad xiinOmega_e","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"and an array of bernstein polynomials","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"mathbfBleft(overlinexiright) = left beginarrayccccc\noperatornameB_0pleft(overlinexiright)  cdots \noperatornameB_ipleft(overlinexiright)  cdots \noperatornameB_ppleft(overlinexiright) endarray right\nquad forall quad overlinexiinleft-11right_mathbbR","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"we can rewrite the bloated definition.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"mathbfN^mathrmCeleft(xiright) =\nmathbfBleft(operatornamef^mathrmCeleft(xiright)right) \nleft(mathbfM^mathrmCmathrmBeright)^intercal\nquad forall quad xiinOmega_e","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"These local base functions can then used to calculate the B-Spline on the local parameter space Omega_e","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"mathbfC^eleft(xiright) =\nmathbfN^mathrmCeleft(xiright)  mathbfP^e\nquad forall quad xiinOmega_e","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"where mathbfP^e is the subset of points corresponding to the base functions (from P_operatornamek^mathrmCleft(eright)+0p till P_operatornamek^mathrmCleft(eright)+pp).","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"pltB = plot(xticks = unique(Ξ_B),\n            xlabel = \"\\$\\\\xi\\$\",\n            ylabel = \"\\$\\\\operatorname{N}^{\\\\mathrm{B},e}_{i,p}\" *\n                     \"\\\\left(\\\\xi\\\\right)\\$\");\npltN = plot(xticks = unique(Ξ),\n            xlabel = \"\\$\\\\xi\\$\",\n            ylabel = \"\\$\\\\operatorname{N}^{\\\\mathrm{C},e}_{i,p}\" *\n                     \"\\\\left(\\\\xi\\\\right)\\$\");\npltC = plot(P[:,1],P[:,2],\n            xlabel = \"\\$x\\$\",\n            ylabel = \"\\$y\\$\",\n            linewidth = 2,\n            label = \"\\$\\\\operatorname{P}_{i}\\$\",\n            color = :green,\n            line = (:dot, 2),\n            marker = (:circle , 5.0, 0.8),\n            markerstrokewidth = 0);\nfor e in 1:size(bezier_ij,1)\n    ξ_e = collect(range(Ξ[bezier_ij[e,1]+p],Ξ[bezier_ij[e,1]+p+1],length=n));\n    P_e = P[ bezier_ij[e,1].+(0:p) , : ];\n    BEO = M_B[ bezier_ij[e,1].+(0:p) , bezier_ij[e,2].+(0:p) ];\n    N_e = B * BEO';\n    C_e = N_e * P_e;\n\n    plot!(pltB,ξ_e,B,color = e,\n          label = [\"\\$\\\\mathbf{N}^{\\\\mathrm{B},$e}\" *\n                   \"\\\\left(\\\\xi\\\\right)\\$\" \"\" \"\"]);\n    plot!(pltN,ξ_e,N_e,color = e,\n          label = [\"\\$\\\\mathbf{N}^{\\\\mathrm{C},$e}\" *\n                   \"\\\\left(\\\\xi\\\\right)\\$\" \"\" \"\"]);\n    plot!(pltC,C_e[:,1],C_e[:,2],color = e,\n          label = \"\\$\\\\mathbf{C}^{$e}\\\\left(\\\\xi\\\\right)\\$\");\nend # for e\n\nplot(pltB,pltN,pltC,\n     layout = (3, 1),\n     size = (600, 800))","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/#NURBS-by-Bézier-extraction","page":"NUBRS 1D Bézier Extraction","title":"NURBS by Bézier extraction","text":"","category":"section"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"To calculate NURBS base functions or curves it is only necessary to consider the weights and apply them onto the localized B-Spline base functions.","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"pltB = plot(xticks = unique(Ξ_B),\n            xlabel = \"\\$\\\\xi\\$\",\n            ylabel = \"\\$\\\\operatorname{N}^{\\\\mathrm{B},e}_{i,p}\" *\n                     \"\\\\left(\\\\xi\\\\right)\\$\");\npltN = plot(xticks = unique(Ξ),\n            xlabel = \"\\$\\\\xi\\$\",\n            ylabel = \"\\$\\\\operatorname{R}^{\\\\mathrm{C},e}_{i,p}\" *\n                     \"\\\\left(\\\\xi\\\\right)\\$\");\npltC = plot(P[:,1],P[:,2],\n            xlabel = \"\\$x\\$\",\n            ylabel = \"\\$y\\$\",\n            linewidth = 2,\n            label = \"\\$\\\\operatorname{P}_{i}\\$\",\n            color = :green,\n            line = (:dot, 2),\n            marker = (:circle , 5.0, 0.8),\n            markerstrokewidth = 0);\nfor e in 1:size(bezier_ij,1)\n    ξ_e = collect(range(Ξ[bezier_ij[e,1]+p],Ξ[bezier_ij[e,1]+p+1],length=n));\n    P_e = P[ bezier_ij[e,1].+(0:p) , : ];\n    weights_e = weights[ bezier_ij[e,1].+(0:p) ];\n    BEO = M_B[ bezier_ij[e,1].+(0:p) , bezier_ij[e,2].+(0:p) ];\n    R_e = B * BEO' .* weights_e';\n    R_e ./= sum(R_e,dims=2);\n    C_e = R_e * P_e;\n\n    plot!(pltB,ξ_e,B,color = e,\n          label = [\"\\$\\\\mathbf{N}^{\\\\mathrm{B},$e}\" *\n                   \"\\\\left(\\\\xi\\\\right)\\$\" \"\" \"\"]);\n    plot!(pltN,ξ_e,R_e,color = e,\n          label = [\"\\$\\\\mathbf{R}^{\\\\mathrm{C},$e}\" *\n                   \"\\\\left(\\\\xi\\\\right)\\$\" \"\" \"\"]);\n    plot!(pltC,C_e[:,1],C_e[:,2],color = e,\n          label = \"\\$\\\\mathbf{C}^{$e}\\\\left(\\\\xi\\\\right)\\$\");\nend # for e\n\nplot(pltB,pltN,pltC,\n     layout = (3, 1),\n     size = (600, 800))","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"","category":"page"},{"location":"literate/nb_nurbs_1d_bezier/","page":"NUBRS 1D Bézier Extraction","title":"NUBRS 1D Bézier Extraction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"doc_NURBStoolbox/#Documentation:-NURBS-Toolbox","page":"NURBS Toolbox","title":"Documentation: NURBS Toolbox","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"CurrentModule = MagMechFEM_Matlab2Julia.NURBStoolbox","category":"page"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Pages = [\"doc_NURBStoolbox.md\"]\nDepth = 2","category":"page"},{"location":"doc_NURBStoolbox/#Module","page":"NURBS Toolbox","title":"Module","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"<style>\n#horlist ul {\ndisplay: grid;\ngrid-template-columns: repeat(auto-fit, minmax(25ch, 1fr));\ngrid-gap: 4px;\nlist-style: none;\n}\n</style>\n<div id=\"horlist\">","category":"page"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"NURBStoolbox","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox","text":"NURBStoolbox\n\nNURBS Toolbox module ported from the Matlab NURBS toolbox of Mark Spink (2000) (can currently be found on Mathworks FileExchange[1]). The Matlab package dates approximately back to the year 2000. Newer versions are written for Octave and are hosted as Octave Community package[2] (those might be compatible with Matlab).\n\nThis package is licensed under GNU General Puplic License version 2.\n\n[1]: Penguian (2010). NURBS Toolbox by D.M. Spink https://www.mathworks.com/matlabcentral/fileexchange/26390-nurbs-toolbox-by-d-m-spink, MATLAB Central File Exchange. Retrieved April 14, 2021.\n\n[2]: M. Spink, D. Claxton, C. de Falco, R. Vazquez (2021-03-09) Nurbs. Octave Forge Community packages. https://octave.sourceforge.io/nurbs/index.html\n\nExports\n\nNURBS\nNURBS1D\nNURBS2D\nbasisfun\nbspdegelev\nbspderiv\nbspeval\nbspkntins\ndemo4surf\ndemocirc\ndemocoons\ndemocurve\ndemocylind\ndemodegelev\ndemodercrv\ndemodersrf\ndemoellip\ndemogeom\ndemohelix\ndemokntins\ndemoline\ndemorect\ndemorevolve\ndemoruled\ndemotorus\nfindspan\nnrb4surf\nnrbcirc\nnrbcoons\nnrbcylind\nnrbdegelev\nnrbderiv\nnrbdeval\nnrbeval\nnrbextrude\nnrbkntins\nnrbline\nnrbmak\nnrbplot\nnrbplot!\nnrbrect\nnrbreverse\nnrbrevolve\nnrbruled\nnrbtestcrv\nnrbtestsrf\nnrbtform\nnrbtransp\nvecangle\nveccross\nvecdot\nvecmag\nvecmag2\nvecnorm_toolbox\nvecrotx\nvecroty\nvecrotz\nvecscale\nvectrans\n\nImports\n\nBase\nCore\nDocStringExtensions\nLinearAlgebra\nPlots\n\n\n\n\n\n","category":"module"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"</div>","category":"page"},{"location":"doc_NURBStoolbox/#Data-Structures","page":"NURBS Toolbox","title":"Data Structures","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"<style>\n#horfield li > p + p::before {\ncontent: \": \";\n}\n#horfield li > p {\ndisplay: contents;\n}\n</style>\n<div id=\"horfield\">","category":"page"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"NURBS\nNURBS1D\nNURBS2D","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.NURBS","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.NURBS","text":"NURBS{I<:Integer,F<:AbstractFloat}\n\nAbstract supertype for NURBS data tayps see NURBS1D and NURBS2D.\n\nBoth curves and surfaces where represented by a structure that where compatible with the Spline Toolbox from Mathworks.\n\n\n\n\n\n","category":"type"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.NURBS1D","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.NURBS1D","text":"NURBS1D{I<:Integer,F<:AbstractFloat} <: NURBS{I,F}\n\nNURBS datatype representing a NURBS curve. Constructed with nrbmak.\n\ninfo: Note:\nThe control points are always converted and stored within the NURBS structure as 4D homogeneous coordinates.\n\nField\n\nform::String\nType name 'B-NURBS'\ndim::Integer\nDimension of the control points\nnumber::Integer\nNumber of Control points\norder::Integer\nOrder of the spline\nknots::Vector{F} where F<:AbstractFloat\nKnot sequence\ncoefs::Matrix{F} where F<:AbstractFloat\nControl Points\n\n\n\n\n\n","category":"type"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.NURBS2D","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.NURBS2D","text":"NURBS2D{I<:Integer,F<:AbstractFloat} <: NURBS{I,F}\n\nNURBS datatype representing a NURBS surface. Constructed with nrbmak.\n\ninfo: Note:\nThe control points are always converted and stored within the NURBS structure as 4D homogeneous coordinates. For a surface the spline degree is a vector [du;dv] containing the order along the U and V directions respectively.\n\nField\n\nform::String\nType name 'B-NURBS'\ndim::Integer\nDimension of the control points\nnumber::Vector{I} where I<:Integer\nNumber of Control points\norder::Vector{I} where I<:Integer\nOrder of the spline\nknots::Array{Vector{F}, 1} where F<:AbstractFloat\nKnot sequence\ncoefs::Array{F, 3} where F<:AbstractFloat\nControl Points\n\n\n\n\n\n","category":"type"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"</div>","category":"page"},{"location":"doc_NURBStoolbox/#Evaluation-Functions/Methods","page":"NURBS Toolbox","title":"Evaluation Functions/Methods","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"basisfun\nbspeval\nnrbmak\nnrbeval\nnrbplot\nnrbplot!","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.basisfun","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.basisfun","text":"basisfun(i::I,u::F,p::I,U::Vector{F}\n        )::Vector{F} where {I<:Integer,F<:AbstractFloat}\n\nCalculates the B-Spline basis function at u.\n\nArguments:\n\ni: knot span from findspan\nu: parametric point\np: spline degree\nU: knot sequence\n\nOutput:\n\nN: basis function vector of lenght p+1\n\nExamples:\n\njulia> N = basisfun(i,u,p,U)\n\nReference:\n\nAlgorithm A2.2 from 'The NURBS BOOK' pg70 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.bspeval","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.bspeval","text":"bspeval(d::I,c::Matrix{F},k::Vector{F},u::Vector{F}\n       )::Matrix{F} where {I<:Integer,F<:AbstractFloat}\n\nEvaluate a univariate B-Spline.\n\nArguments:\n\nd: degree of the B-Spline\nc: control points, matrix of size (dim,nc)\nk: knot sequence, vector of size nk\nu: parametric evaluation points, vector of size nu\n\nOutput:\n\np: Evaluated points, matrix of size (dim,nu)\n\nExamples:\n\njulia> p = bspeval(d,c,k,u)\n\nReference:\n\nAlgorithm A3.1 from 'The NURBS BOOK' pg82 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbmak","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbmak","text":"nrbmak(coefs::Union{Matrix{F}, Array{F,3}},\n       knots::Union{Vector{F}, Vector{Vector{F}}}\n      )::NURBS where {F<:AbstractFloat}\n\nConstruct the NURBS structure given the control points and the knots.\n\nThis function is used as a convenient means of constructing the NURBS data structure. Many of the other functions in the toolbox rely on the NURBS structure been correctly defined. This function not only constructs the proper structure, but also checks for consistency. The user is still free to build his own structure, in fact a few functions in the toolbox do this for convenience.\n\nArguments:\n\ncoefs: Control points, these can be either Cartesian or homogeneous coordinates. For a curve the control points are represented by a matrix of size (dim,nu) and for a surface by a multidimensional array of size (dim,nu,nv). Where nu is number of points along the parametric U direction, and nv the number of points along the V direction. dim is the dimension valid options are:\n2 : (x,y)        2D Cartesian coordinates   3 : (x,y,z)      3D Cartesian coordinates   4 : (wx,wy,wz,w) 4D homogeneous coordinates\nknots: Non-decreasing knot sequence spanning the interval [0.0;1.0]. It is assumed that the curves and surfaces are clamped to the start and end control points by knot multiplicities equal to the spline order. For a curve knots form a vector and for a surface the knots are stored by two vectors for U and V in a vector of vectors [uknots, vknots]\n\nOutput:\n\nnurbs: NURBS data structure see NURBS1D and NURBS2D.\n\ninfo: Note:\nThe control points are always converted and stored within the NURBS structure as 4D homogeneous coordinates. For a surface the spline degree is a vector [du;dv] containing the order along the U and V directions respectively.\n\nExamples:\n\nConstruct a 2D line from [0.0;0.0] to [1.5;3.0]. For a straight line a spline of order 2 is required. Note that the knot sequence has a multiplicity of 2 at the start [0.0;0.0] and end [1.0;1.0] in order to clamp the ends.\n\njulia> line = nrbmak([0.0 1.5; 0.0 3.0],vec([0.0 0.0 1.0 1.0]))\n\nConstruct a surface in the x-y plane i.e\n\n^  (0.0,1.0) ------------ (1.0,1.0)\n|      |                      |\n| V    |                      |\n|      |      Surface         |\n|      |                      |\n|      |                      |\n|  (0.0,0.0) ------------ (1.0,0.0)\n|\n|------------------------------------>\n                                  U\n\njulia> coefs = cat([0.0 0.0; 0.0 1.0],[1.0 1.0; 0.0 1.0],dims=3);\njulia> knots = [vec([0.0 0.0 1.0 1.]),vec([0.0 0.0 1.0 1.0])];\njulia> plane = nrbmak(coefs,knots)\n\nReference:\n\nrelated data types: NURBS1D and NURBS2D\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbeval","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbeval","text":"nrbeval(nurbs::NURBS{I,F},\n        tt::Union{Vector{F}, Vector{Vector{F}}, Matrix{F}} [,\n        flag::Symbol=:cartesian]\n       ) where {I<:Integer, F<:AbstractFloat}\n\nEvaluate a NURBS structure at parametric points.\n\nEvaluation of NURBS curves or surfaces at parametric points along the U and V directions. Either homogeneous coordinates are returned if the flag is set accordingly otherwise cartesian coordinates. This function utilises the function bspeval.\n\nArguments:\n\nnurbs: NURBS structure\ntt: parametric evaluation points either as Vector{F} or Vector{Vector{F}}\nflag: flag indicating that cartesian coordinates or homogeneous coordinates should be returned (valid values: :cartesian (default) or :homogeneous)\n\nOutput:\n\np::Union{Matrix{F},Array{F,3}}: Evaluated points on the NURBS curve or  surface as cartesian coordinates (x,y,z). If flag=:homogeneous is set the  points are returned as homogeneous coordinates (wx,wy,wz).\nw::Union{Vector{F},Matrix{F}}: Weights of the homogeneous coordinates of the evaluated points. Note: Only returned it the corresponding flag is set (see above).\n\nExamples:\n\njulia> p = nrbeval(nurbs,tt)\njulia> p,w = nrbeval(nurbs,tt,:homogeneous)\njulia> p = nrbeval(srf,[ut,vt])\n\nEvaluate the NURBS circle with twenty points from 0.0 to 1.0.\n\njulia> nrb = nrbcirc();\njulia> ut = collect(range(0.0,stop=1.0,length=20))\njulia> p = nrbeval(nrb,ut)\n\nnote: Note:\nContrary to the Matlab version does this ported version evaluates not the varargout count to switch between different return values. A symbol flag is used instead.\n\nReference\n\nsee also: bspeval\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbplot","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbplot","text":"nrbplot(nurbs::NURBS{I,F},\n        npts::Union{I, Vector{I}} [;\n        plotargs... ]\n       ) where {I<:Integer,F<:AbstractFloat}\n\nPlot a NURBS curve or a surface.\n\nArguments:\n\nnurbs: NURBS structure\nnpts: Number of evaluation points, for a surface a vector with two elements for the number of points along the U and V directions respectively.\nplotargs: plot arguments to pass to the wrapped plot function\n\nnote: Note:\nFor 3D Plots nrbplot uses the Plots.pyplot() backend. Use plot arguments compatible with that backend.\n\nExamples:\n\njulia> nrbplot(nrb,subd)\njulia> nrbplot(nrb,subd,c=:winter)\n\nPlot the test surface with 20 points along the U direction and 30 along the V direction\n\njulia> nrbplot(nrbtestsrf,[20;30],c=:copper)\n\nnote: Note:\nContrary to the Matlab version does this ported version supports no specialised input arguments just pass named plot arguments which will be passed to the wrapped plot functions.\n\nnote: Note:\nIt is also possible to overload the Julia plot() function with the mechanic Recipes.\n\nReference\n\nsee also: nrbeval\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbplot!","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbplot!","text":"nrbplot!(nurbs::NURBS{I,F},\n         npts::Union{I, Vector{I}} [;\n         plotargs... ]\n        ) where {I<:Integer,F<:AbstractFloat}\n\nPlot a NURBS curve or a surface.\n\nWrapper of nrbplot in order to introduce the Julia plot append mechanic for that plot routine.\n\nnote: Note:\nThis function serves only as wrapper for the nrbplot function for input arguments and usage look at that function.\n\nReference\n\nsee nrbplot\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#Utility-and-Modification-Functions/Methods","page":"NURBS Toolbox","title":"Utility and Modification Functions/Methods","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"findspan\nvecscale\nvectrans\nvecrotx\nvecroty\nvecrotz\nnrbtform\nnrbextrude\nnrbrevolve\nvecdot\nveccross\nvecmag\nvecmag2\nvecnorm_toolbox\nvecangle\nnrbtransp\nbspdegelev\nnrbdegelev\nbspkntins\nnrbkntins\nbspderiv\nnrbderiv\nnrbdeval\nnrbreverse\nnrbruled\nnrbcoons","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.findspan","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.findspan","text":"findspan(n::I,p::I,u::F,U::Vector{F})::I where {I<:Integer,F<:AbstractFloat}\n\nFind the span of a B-Spline knot vector at a parametric point\n\nArguments:\n\nn: nuber of control points -1\np: spline degree\nn: parametric point\nU: knot sequence\n\nOutput:\n\ns: knot span of u in U\n\nExamples:\n\njulia> s = findspan(n,p,u,U)\n\nReference:\n\nAlgorithm A2.1 from 'The NURBS BOOK' pg68 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecscale","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecscale","text":"vecscale(svec::Vector{F})::Matrix{F} where {F<:AbstractFloat}\n\nTransformation matrix for a scaling.\n\nReturns a (4x4) Transformation matrix for scaling.\n\nThe matrix is:\n\n[ sx   0   0   0]\n[  0  sy   0   0]\n[  0   0  sz   0]\n[  0   0   0   1]\n\nArguments:\n\nsvec: A vectors defining the scaling along the x,y and z axes. i.e. [sx; sy; sy]\n\nOutput:\n\nst: Scaling Transformation Matrix\n\nExamples:\n\njulia> ss = vecscale(svec)\n\nScale up the NURBS line [0.0;0.0;0.0] - [1.0;1.0;1.0] by 3 along the x-axis, 2 along the y-axis and 4 along the z-axis.\n\njulia> line = nrbline(vec([0.0 0.0 0.0]),vec([1.0 1.0 1.0]));\njulia> scale = vecscale(vec([3.0 2.0 4.0]));\njulia> sline = nrbtform(line, scale)\n\nReference\n\nsee also: nrbtform\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vectrans","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vectrans","text":"vectrans(tvec::Vector{F})::Matrix{F} where {F<:AbstractFloat}\n\nTransformation matrix for a translation.\n\nReturns a (4x4) Transformation matrix for translation.\n\nThe matrix is:\n\n[ 1   0   0  tx ]\n[ 0   1   0  ty ]\n[ 0   0   1  tz ]\n[ 0   0   0   1 ]\n\nArguments:\n\ntvec: A vectors defining the translation along the x,y and z axes. i.e. [tx; ty; ty]\n\nOutput:\n\nst: Translation Transformation Matrix\n\nExamples:\n\njulia> st = vectrans(tvec)\n\nTranslate the NURBS line [0.0;0.0;0.0] - [1.0;1.0;1.0] by 3 along the x-axis, 2 along the y-axis and 4 along the z-axis.\n\njulia> line = nrbline(vec([0.0 0.0 0.0]),vec([1.0 1.0 1.0]));\njulia> trans = vectrans(vec([3.0 2.0 4.0]));\njulia> tline = nrbtform(line, trans);\n\nReference\n\nsee also: nrbtform\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecrotx","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecrotx","text":"vecrotx(angle::F)::Matrix{F} where {F<:AbstractFloat}\n\nTransformation matrix for a rotation around the x axis.\n\nReturn the (4x4) Transformation matrix for a rotation about the x axis by the defined angle.\n\nThe matrix is:\n\n[ 1         0            0          0]\n[ 0     cos(angle)  -sin(angle)     0]\n[ 0     sin(angle)   cos(angle)     0]\n[ 0         0            0          1]\n\nArguments:\n\nangle: rotation angle defined in radians\n\nOutput:\n\nrx: (4x4) Transformation matrix.\n\nExamples:\n\njulia> rz = vecrotx(angle)\n\nRotate the NURBS line [0.0;0.0;0.0] - [3.0;3.0;3.0] by 45 degrees around the x-axis\n\njulia> line = nrbline(vec([0.0 0.0 0.0]),vec([3.0 3.0 3.0]));\njulia> rotate = vecrotx(pi/4);\njulia> rline = nrbtform(line, rotate)\n\nReference\n\nsee also: nrbtform\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecroty","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecroty","text":"vecroty(angle::F)::Matrix{F} where {F<:AbstractFloat}\n\nTransformation matrix for a rotation around the y axis.\n\nReturn the (4x4) Transformation matrix for a rotation about the y axis by the defined angle.\n\nThe matrix is:\n\n[  cos(angle)       0        sin(angle)       0]\n[      0            1            0            0]\n[ -sin(angle)       0        cos(angle)       0]\n[      0            0            0            1]\n\nArguments:\n\nangle: rotation angle defined in radians\n\nOutput:\n\nry: (4x4) Transformation matrix.\n\nExamples:\n\njulia> ry = vecroty(angle)\n\nRotate the NURBS line [0.0;0.0;0.0] - [3.0;3.0;3.0] by 45 degrees around the y-axis\n\njulia> line = nrbline(vec([0.0 0.0 0.0]),vec([3.0 3.0 3.0]));\njulia> rotate = vecroty(pi/4);\njulia> rline = nrbtform(line, rotate)\n\nReference\n\nsee also: nrbtform\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecrotz","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecrotz","text":"vecrotz(angle::F)::Matrix{F} where {F<:AbstractFloat}\n\nTransformation matrix for a rotation around the z axis.\n\nReturn the (4x4) Transformation matrix for a rotation about the z axis by the defined angle.\n\nThe matrix is:\n\n[  cos(angle)  -sin(angle)       0          0]\n[ -sin(angle)   cos(angle)       0          0]\n[      0            0            1          0]\n[      0            0            0          1]\n\nArguments:\n\nangle: rotation angle defined in radians\n\nOutput:\n\nrz: (4x4) Transformation matrix.\n\nExamples:\n\njulia> rz = vecrotz(angle)\n\nRotate the NURBS line [0.0;0.0;0.0] - [3.0;3.0;3.0] by 45 degrees around the z-axis\n\njulia> line = nrbline(vec([0.0 0.0 0.0]),vec([3.0 3.0 3.0]));\njulia> rotate = vecrotz(pi/4);\njulia> rline = nrbtform(line, rotate)\n\nReference\n\nsee also: nrbtform\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtform","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtform","text":"nrbtform(nurbs::NURBS{I,F},tmat::Matrix{F}\n        )::NURBS{I,F} where {I<:Integer,F<:AbstractFloat}\n\nApply transformation matrix to the NURBS.\n\nThe NURBS is transform as defined a transformation matrix of size (4,4), such as a rotation, translation or change in scale. The transformation matrix can define a single transformation or multiple series of transformations. The matrix can be simple constructed by the functions vecscale, vectrans, vecrotx, vecroty and vecrotz.\n\nArguments:\n\nnurbs: NURBS data structure (see nrbmak for details).\ntmatrix: Transformation matrix, a matrix of size (4,4) defining a single or multiple transformations.\n\nOutput:\n\ntnurbs: The transformed NURBS data structure.\n\nExamples:\n\njulia> tnurbs = nrbtform(nurbs,tmatrix)\n\nRotate a square by 45 degrees about the z axis.\n\njulia> rsqr = nrbtform(nrbrect(), vecrotz(deg2rad(45)));\njulia> nrbplot(rsqr,[10;10])\n\nReference\n\nsee also: vecscale, vectrans, vecrotx, vecroty and vecrotz\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbextrude","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbextrude","text":"nrbextrude(curve::NURBS1D{I,F},vector::Vector{F}\n          )::NURBS2D{I,F} where {I<:Integer,F<:AbstractFloat}\n\nConstruct a NURBS surface by extruding a NURBS curve.\n\nConstructs a NURBS surface by extruding a NURBS curve along a defined vector. The NURBS curve forms the U direction of the surface edge, and extruded along the vector in the V direction. Note NURBS surfaces cannot be extruded.\n\nArguments:\n\ncrv: NURBS curve to extrude, see nrbmak.\nvec: Vector along which the curve is extruded.\n\nOutput:\n\nsrf: NURBS surface constructed.\n\nExamples:\n\njulia> srf = nrbextrude(crv,vec)\n\nForm a hollow cylinder by extruding a circle along the z-axis.\n\nsrf = nrbextrude(nrbcirc(),[0.0;0.0;1.0]);\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbrevolve","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbrevolve","text":"nrbrevolve(crv::NURBS1D{I,F},vec::Vector{F},\n           pnt::Vector{F}=[0.0;0.0;0.0],theta::F=2.0*π\n          )::NURBS2D{I,F} where {I<:Integer,F<:AbstractFloat}\n\nConstruct a NURBS surface by revolving the profile NURBS curve around an axis defined by a point and vector.\n\nArguments:\n\ncrv: NURBS curve to revolve, see nrbmak.\nvec: Vector defining the direction of the rotation axis.\npnt: Coordinate of the point used to define the axis of rotation.\ntheta: Angle to revolve the curve, default 2*π.\n\nOutput:\n\nsrf: Constructed surface.\n\nExamples:\n\njulia> srf = nrbrevolve(crv,vec)\njulia> srf = nrbrevolve(crv,vec,pnt)\njulia> srf = nrbrevolve(crv,vec,pnt,ang)\n\nConstruct a sphere by rotating a semicircle around a x-axis.\n\njulia> crv = nrbcirc(1.0,[0.0;0.0;0.0],0.0,pi);\njulia> srf = nrbrevolve(crv,[1.0;0.0;0.0],[0.0;0.0;0.0]);\njulia> nrbplot(srf,[20;20]);\n\nThe algorithm:\n\nvectrans the point to the origin [0.0;0.0;0.0]\nrotate the vector into alignment with the z-axis\nfor each control point along the curve\ndetermine the radius and angle of control point to the z-axis\nconstruct a circular arc in the x-y plane with this radius and start angle and sweep angle theta\ncombine the arc and profile, coefs and weights.\nnext control point\nrotate and vectrans the surface back into position by reversing 1 and 2.\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecdot","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecdot","text":"vecdot(vec1::Matrix{F},vec2::Matrix{F})::Matrix{F} where {F<:AbstractFloat}\n\nor\n\nvecdot(vec1::Vector{F},vec2::Vector{F})::F where {F<:AbstractFloat}\n\nDetermines scalar dot product of two vectors.\n\nArguments:\n\nvec1, vec2: An array of column vectors represented by a matrix of size (dim,nv), where dim is the dimension of the vector and nv the number of vectors.\n\nOutput:\n\ndot: Row vector of scalars, each element corresponding to the dot product of the respective components in vec1 and vec2.\n\nExamples:\n\njulia> dot = vecdot(vec2,vec2)\n\nDetermine the dot product of\n\n[2.3;3.4;5.6] and [1.2;4.5;1.2]\n[5.1;0.0;2.3] and [2.5;3.2;4.0]\n\njulia> dot = vecdot([2.3 5.1; 3.4 0.0; 5.6 2.3],[1.2 2.5; 4.5 3.2; 1.2 4.0])\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.veccross","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.veccross","text":"veccross(vec1::Matrix{F},vec2::Matrix{F}\n        )::Matrix{F} where {F<:AbstractFloat}\n\nor\n\nveccross(vec1::Vector{F},vec2::Vector{F}\n        )::Vector{F} where {F<:AbstractFloat}\n\nDetermines cross product of two vectors.\n\nArguments:\n\nvec1, vec2: An array of column vectors represented by a matrix of size (dim,nv), where dim is the dimension of the vector and nv the number of vectors.\n\nOutput:\n\ncross: Array of column vectors, each element is corresponding to the cross product of the respective components in vec1 and vec2.\n\nExamples:\n\njulia> cross = veccross(vec2,vec2)\n\nDetermine the cross product of\n\n[2.3;3.4;5.6] and [1.2;4.5;1.2]\n[5.1;0.0;2.3] and [2.5;3.2;4.0]\n\njulia> cross=veccross([2.3 5.1; 3.4 0.0; 5.6 2.3],[1.2 2.5; 4.5 3.2; 1.2 4.0])\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecmag","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecmag","text":"vecmag(vec::Matrix{F})::Matrix{F} where {F<:AbstractFloat}\n\nor\n\nvecmag(vec::Vector{F})::F where {F<:AbstractFloat}\n\nDetermines the magnitude of vectors.\n\nArguments:\n\nvec: An array of column vectors represented by a matrix of size (dim,nv), where dim is the dimension of the vector and nv the number of vectors.\n\nOutput:\n\nmvec: Magnitude of the vectors, vector of size (1,nv).\n\nExamples:\n\njulia> mvec = vecmag(vec)\n\nFind the magnitude of the two vectors [0.0;2.0;1.3] and [1.5;3.4;2.3].\n\njulia> mvec = vecmag([0.0 1.5; 2.0 3.4; 1.3 2.3])\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecmag2","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecmag2","text":"vecmag2(vec::Matrix{F})::Matrix{F} where {F<:AbstractFloat}\n\nor\n\nvecmag2(vec::Vector{F})::F where {F<:AbstractFloat}\n\nDetermines the squared magnitude of vectors.\n\nArguments:\n\nvec: An array of column vectors represented by a matrix of size (dim,nv), where dim is the dimension of the vector and nv the number of vectors.\n\nOutput:\n\nmvec: Squared magnitude of the vectors, vector of size (1,nv).\n\nExamples:\n\njulia> mvec = vecmag2(vec)\n\nFind the squared magnitude of the two vectors [0.0;2.0;1.3] and [1.5;3.4;2.3].\n\njulia> mvec = vecmag2([0.0 1.5; 2.0 3.4; 1.3 2.3])\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecnorm_toolbox","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecnorm_toolbox","text":"vecnorm_toolbox(vec::Union{Matrix{F}, Array{F,3}}\n               )::Union{Matrix{F}, Array{F,3}} where {F<:AbstractFloat}\n\nor\n\nvecnorm_toolbox(vec::Vector{F})::Vector{F} where {F<:AbstractFloat}\n\nNormalises the array of vectors, returning the unit vectors.\n\nArguments:\n\nvec: An array of column vectors represented by a matrix of size (dim,nv), where dim is the dimension of the vector and nv the number of vectors.\n\nOutput:\n\nnvec: Normalised vectors, matrix the same size as vec.\n\nExamples:\n\njulia> nvec = vecnorm_toolbox(vec)\n\nNormalise the two vectors [0.0;2.0;1.3] and [1.5;3.4;2.3].\n\njulia> nvec = vecnorm_toolbox([0.0 1.5; 2.0 3.4; 1.3 2.3])\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.vecangle","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.vecangle","text":"vecangle(num::Matrix{F},den::Matrix{F}\n        )::Matrix{F} where {F<:AbstractFloat}\n\nor\n\nvecangle(num::F,den::F)::Vector{F} where {F<:AbstractFloat}\n\nAn alternative to atan, returning an arctangent in the range 0 to 2*π.\n\nThe components of the vector ang are the arctangent of the corresponding enties of num./den. This function is an alternative for atan, returning an angle in the range 0 to 2*π.\n\nArguments:\n\nnum: Numerator, vector of size (1,nv).\nden: Denominator, vector of size (1,nv).\n\nOutput:\n\nang: Arctangents, row vector of angles.\n\nExamples:\n\njulia> ang = vecmag2(num,dum)\n\nFind the atan(1.2,2.0) and atan(1.5,3.4) using vecangle.\n\njulia> ang = vecangle([1.2 1.5], [2.0 3.4])\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtransp","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtransp","text":"nrbtransp(srf::NURBS2D{I,F}\n         )::NURBS2D{I,F} where {I<:Integer,F<:AbstractFloat}\n\nTranspose a NURBS surface, by swapping U and V directions.\n\nUtility function that transposes a NURBS surface, by swapping U and V directions. NURBS curves cannot be transposed.\n\nArguments:\n\nsrf: NURBS surface, see nrbmak.\n\nOutput:\n\ntsrf: NURBS surface with U and V diretions transposed.\n\nExamples:\n\njulia> tsrf = nrbtransp(srf)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.bspdegelev","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.bspdegelev","text":"bspdegelev(d::I,c::Matrix{F},k::Vector{F},t::I\n          ) where {I<:Integer,F<:AbstractFloat}\n\nDegree elevate a univariate B-Spline.\n\nArguments:\n\nd: Degree of the B-Spline.\nc: Control points, matrix of size (dim,nc).\nk: Knot sequence, vector of size nk.\nt: Raise the B-Spline degree t times.\n\nOutput:\n\nic: Control points of the new B-Spline.\nik: Knot vector of the new B-Spline.\n\nExamples:\n\njulia> ic,ik = bspdegelev(d,c,k,t)\n\nReference:\n\nAlgorithm A5.9 from 'The NURBS BOOK' pg206 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbdegelev","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbdegelev","text":"nrbdegelev(nurbs::NURBS{I,F},ntimes::Union{I, Vector{I}}\n          )::NURBS{I,F} where {I<:Integer,F<:AbstractFloat}\n\nDegree elevates the NURBS curve or surface. This function uses the B-Spline function bspdegelev.\n\nArguments:\n\nnurbs: NURBS structure (curve or surface see nrbmak)\nntimes: number or pair of numbers indicating how many times the structure shall be degree elevated along U direction or V direction\n\nOutput:\n\nenurbs: new NURBS structure with degrees elevated\n\nExamples:\n\njulia> ecrv = nrbdegelev(crv,utimes);\njulia> esrf = nrbdegelev(srf,[utimes;vtimes]);\n\nIncrease the NURBS surface degree twice along the V direction.\n\njulia> esrf = nrbdegelev(srf,[0;2]);\n\nReference\n\nsee also: bspdegelev\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.bspkntins","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.bspkntins","text":"bspkntins(d::I,c::Matrix{F},k::Vector{F},u::Vector{F}\n         ) where {I<:Integer,F<:AbstractFloat}\n\nInsert knots into a univariate B-Spline.\n\nArguments:\n\nd: Degree of the B-Spline.\nc: Control points, matrix of size (dim,nc).\nk: Knot sequence, vector of size nk.\nu: Row vector of knots to be inserted, size nu.\n\nOutput:\n\nic: Control points of the new B-Spline, of size (dim,nc+nu).\nik: Knot vector of the new B-Spline, of size (nk+nu).\n\nExamples:\n\njulia> ic,ik = bspkntins(d,c,k,u)\n\nReference:\n\nAlgorithm A5.4 from 'The NURBS BOOK' pg164 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbkntins","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbkntins","text":"nrbkntins(nurbs::NURBS{I,F}, iknots::Union{Vector{F}, Vector{Vector{F}}}\n         )::NURBS{I,F} where {I<:Integer,F<:AbstractFloat}\n\nInsert a single or multiple knots into a NURBS curve or surface.\n\nInserts knots into the NURBS data structure, these can be knots at new positions or at the location of existing knots to increase the multiplicity. Note that the knot multiplicity cannot be increased beyond the order of the spline. Knots along the V direction can only inserted into NURBS surfaces, not curves that are always defined along the U direction. This function uses the B-Spline function bspkntins.\n\nArguments:\n\nnurbs: NURBS structure (curve or surface see nrbmak)\niknots: vektor of knots or pair of vector of knots to insert into respective U,V directions of the structure\n\nOutput:\n\nenurbs: new NURBS structure with degrees elevated\n\nExamples:\n\njulia> icrv = nrbkntins(crv,iknots);\njulia> isrf = nrbkntins(srf,[iuknots,ivknots]);\n\ninfo: Note:\nNo knot multiplicity will be increased beyond the order of the spline.\n\nInsert two knots into a curve, one at 0.3 and another twice at 0.4.\n\njulia> icrv = nrbkntins(crv, vec([0.3 0.4 0.4]))\n\nInsert into a surface two knots as (1) into the U knot sequence and one knot into the V knot sequence at 0.5.\n\njulia> isrf = nrbkntins(srf, [vec([0.3 0.4 0.4]),[0.5]])\n\nReference\n\nsee also: bspkntins\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.bspderiv","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.bspderiv","text":"bspderiv(d::I,c::Matrix{F},k::Vector{F}\n        ) where {I<:Integer,F<:AbstractFloat}\n\nEvaluate the control points and knot sequence of the derivative of a univariate B-Spline.\n\nArguments:\n\nd: Degree of the B-Spline.\nc: Control points, matrix of size (dim,nc).\nk: Knot sequence, vector of size nk.\n\nOutput:\n\ndc: Control points of the derivative.\ndk: Knot sequence of the derivative.\n\nExamples:\n\njulia> dc,dk = bspderiv(d,c,k)\n\nReference:\n\nderived from Algorithm A3.3 from 'The NURBS BOOK' pg98 (Les Piegl, Wayne Tiller (1997))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbderiv","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbderiv","text":"nrbderiv(nurbs::NURBS{I,F}) where {I<:Integer,F<:AbstractFloat}\n\nConstruct the first derivative representation of a NURBS curve or surface.\n\nThe derivatives of a B-Spline are themselves a B-Spline of lower degree, giving an efficient means of evaluating multiple derivatives. However, although the same approach can be applied to NURBS, the situation for NURBS is more complex. I have at present restricted the derivatives to just the first. I don't claim that this implentation is the best approach, but it will have to do for now. The function returns a data struture that for a NURBS curve contains the first derivatives of the B-Spline representation. Remember that a NURBS curve is represented by a univariate B-Spline using the homogeneous coordinates. The derivative data structure can be evaluated later with the function nrbdeval.\n\nArguments:\n\nnurbs: NURBS data structure, see nrbmak.\n\nOutput:\n\ndnurbs: A data structure that represents the first derivatives of a NURBS curve or surface.\n\nExamples:\n\njulia> dnurbs = nrbderiv(nurbs);\n\nSee the function nrbdeval for an example.\n\nReference\n\nsee also: bspderiv, nrbdeval\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbdeval","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbdeval","text":"nrbdeval(nurbs::NURBS{I,F},\n         dnurbs::Union{NURBS1D{I,F}, Vector{NURBS2D{I,f}}},\n         tt::Union{Vector{F}, Vector{Vector{F}}, Matrix{F}}\n        ) where {I<:Integer,F<:AbstractFloat}\n\nEvaluation of the derivative NURBS curve or surface.\n\nArguments:\n\nnurbs: NURBS structure\ndnurbs: NURBS derivative representation of nurbs\ntt: parametric evaluation points either as Vector{F} or Vector{Vector{F}}\n\nOutput:\n\npnt::Union{Matrix{F},Array{F,3}}: Evaluated points.\njac::Union{Matrix{F}, Vector{Array{F,3}}}: Evaluated first derivatives (Jacobian).\n\nExamples:\n\njulia> pnt, jac = nrbdeval(nurbs, dnurbs, tt)\njulia> pnt, jac = nrbdeval(nurbs, dnurbs, [tu,tv])\n\nDetermine the first derivatives a NURBS curve at 9 points for 0.0 to 1.0.\n\njulia> tt = collect(range(0.0, 1.0, length=9));\njulia> dcrv = nrbderiv(crv);\njulia> pnts, jac = nrbdeval(crv, dcrv, tt)\n\nReference\n\nsee also: nrbeval, nrbderiv\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbreverse","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbreverse","text":"nrbreverse(nurbs::NURBS{I,F}\n        )::NURBS{I,F} where {I<:Integer,F<:AbstractFloat}\n\nUtility function to reverse the evaluation direction of a NURBS curve or surface.\n\nArguments:\n\nnurbs: NURBS data structure (see nrbmak for details).\n\nOutput:\n\nrnurbs: The transformed NURBS data structure.\n\nExamples:\n\njulia> rnurbs = nrbreverse(nurbs)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbruled","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbruled","text":"nrbruled(crv1::NURBS1D{I,F},crv2::NURBS1D{I,F}\n        )::NURBS2D{I,F} where {I<:Integer,F<:AbstractFloat}\n\nConstructs a ruled surface between two NURBS curves. The ruled surface is ruled along the V direction.\n\nArguments:\n\ncrv1: First NURBS curve, see nrbmak.\ncrv2: Second NURBS curve, see nrbmak.\n\nOutput:\n\nsrf: Ruled NURBS surface.\n\nExamples:\n\njulia> srf = nrbruled(crv1,crv2)\n\nConstruct a ruled surface between a semicircle and a straight line.\n\njulia> cir = nrbcirc(1.0,[0.0;0.0;0],0.0,1.0*pi);\njulia> line = nrbline(vec([-1 0.5 1]),vec([1 0.5 1]));\njulia> srf = nrbruled(cir,line);\njulia> nrbplot(srf,[20;20]);\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbcoons","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbcoons","text":"nrbcoons(u1::NURBS1D{I,F},u2::NURBS1D{I,F},\n         v1::NURBS1D{I,F},v2::NURBS1D{I,F}\n        )::NURBS2D{I,F} where {I<:Integer,F<:AbstractFloat}\n\nConstruction of a Coons patch.\n\nConstruction of a bilinearly blended Coons surface patch from four NURBS curves that define the boundary.\n\nThe orientation of the four NURBS boundary curves.\n\n   ^ V direction\n   |\n   |      u2\n   ------->--------\n   |              |\n   |              |\nv1 ^   Surface    ^ v2\n   |              |\n   |              |\n   ------->-----------> U direction\n          u1\n\nArguments:\n\nu1: NURBS curve defining the bottom U direction boundary of the constructed NURBS surface.\nu2: NURBS curve defining the top U direction boundary of the constructed NURBS surface.\nv1: NURBS curve defining the bottom V direction boundary of the constructed NURBS surface.\nv1: NURBS curve defining the top V direction boundary of the constructed NURBS surface.\n\nOutput:\n\nsrf: Coons NURBS surface patch.\n\nExamples:\n\njulia> srf = nrbcoons(u1, u2, v1, v2)\n\nDefine four NURBS curves and construct a Coons surface patch.\n\njulia> pnts = [0.0  3.0  4.5  6.5 8.0 10.0;\n               0.0  0.0  0.0  0.0 0.0  0.0;\n               2.0  2.0  7.0  4.0 7.0  9.0];\njulia> crv1 = nrbmak(pnts, vec([0 0 0 1/3 0.5 2/3 1 1 1]));\njulia> pnts= [ 0.0  3.0  5.0  8.0 10.0;\n              10.0 10.0 10.0 10.0 10.0;\n               3.0  5.0  8.0  6.0 10.0];\njulia> crv2 = nrbmak(pnts, vec([0 0 0 1/3 2/3 1 1 1]));\njulia> pnts= [0.0 0.0 0.0  0.0;\n              0.0 3.0 8.0 10.0;\n              2.0 0.0 5.0  3.0];\njulia> crv3 = nrbmak(pnts, vec([0 0 0 0.5 1 1 1]));\njulia> pnts= [10.0 10.0 10.0 10.0 10.0;\n               0.0   3.0  5.0  8.0 10.0;\n               9.0   7.0  7.0 10.0 10.0];\njulia> crv4 = nrbmak(pnts, vec([0 0 0 0.25 0.75 1 1 1]));\njulia> srf = nrbcoons(crv1, crv2, crv3, crv4);\njulia> nrbplot(srf,[20;20]);\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#Recipes-for-NURBS-Structures","page":"NURBS Toolbox","title":"Recipes for NURBS Structures","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"nrbline\nnrbrect\nnrb4surf\nnrbcirc\nnrbcylind","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbline","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbline","text":"nrbline()::NURBS1D\n\nor\n\nnrbline(p1::Vector{F},p2::Vector{F})::NURBS1D where {F<:AbstractFloat}\n\nConstruct a straight line.\n\nConstructs NURBS data structure for a straight line. If coordinates are included the function returns a unit straight line along the x-axis.\n\nArguments:\n\np1: 2D or 3D cartesian coordinate of the start point.\np2: 2D or 3D cartesian coordinate of the end point.\n\nOutput:\n\ncrv: NURBS curve for a straight line.\n\nExamples:\n\njulia> crv = nrbline()\njulia> crv = nrbline(p1,p2)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbrect","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbrect","text":"nrbrect()::NURBS1D\n\nor\n\nnrbrect(size::F)::NURBS1D where {F<:AbstractFloat}\n\nor\n\nnrbrect(width::F,height::F)::NURBS1D where {F<:AbstractFloat}\n\nConstruct NURBS representation of a rectangle.\n\nConstruct a rectangle or square in the x-y plane with the bottom corner at (0,0,0). If there are no arguments provided the function constructs a unit square.\n\nArguments:\n\nsize: Size of the square (width = height).\nwidth: Width of the rectangle (along x-axis).\nheight: Height of the rectangle (along y-axis).\n\nOutput:\n\ncrv: NURBS curve for a straight line.\n\nExamples:\n\njulia> crv = nrbrect()\njulia> crv = nrbrect(size)\njulia> crv = nrbrect(width, height)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrb4surf","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrb4surf","text":"nrb4surf(p11::Vector{F},p12::Vector{F},p21::Vector{F},p22::Vector{F}\n        )::NURBS2D where {F<:AbstractFloat}\n\nConstructs a bilinear surface defined by four coordinates.\n\nThe position of the corner points\n\n^ V direction\n|\n----------------\n|p21        p22|\n|              |\n|    SRF       |\n|              |\n|p11        p12|\n-------------------> U direction\n\nArguments:\n\np11: Cartesian coordinate of the lhs bottom corner point.\np12: Cartesian coordinate of the rhs bottom corner point.\np21: Cartesian coordinate of the lhs top corner point.\np22: Cartesian coordinate of the rhs top corner point.\n\nOutput:\n\nsrf: NURBS bilinear surface, see nrbmak.\n\nExamples:\n\njulia> srf = nrb4surf(p11,p12,p21,p22)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbcirc","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbcirc","text":"nrbcirc(radius::F=1.0,center::Vector{F}=[0.0;0.0;0.0],\n        sang::F=0.0,eang::F=2.0*π)::NURBS1D where {F<:AbstractFloat}\n\nConstructs NURBS data structure for a circular arc in the x-y plane. If no arguments are supplied a unit circle with center [0.0;0.0] is constructed.\n\nAngles are defined as positive in the anti-clockwise direction.\n\nArguments:\n\nradius: Radius of the circle, default 1.0\ncenter: Center of the circle, default [0.0;0.0;0.0]\nsang: Start angle, default 0 degrees\neang: End angle 360 degrees\n\nOutput:\n\ncrv: NURBS curve for a circular arc.\n\nExamples:\n\njulia> crv = nrbcirc()\njulia> crv = nrbcirc(radius)\njulia> crv = nrbcirc(radius,center)\njulia> crv = nrbcirc(radius,center,sang,eang)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbcylind","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbcylind","text":"nrbcylind(height::F=1.0,radius::F=1.0,center::Vector{F}=[0.0;0.0;0.0],\n          sang::F=0.0,eang::F=2.0*π)::NURBS2D where {F<:AbstractFloat}\n\nConstruct a cylinder or cylindrical patch by extruding a circular arc (see nrbcirc).\n\nArguments:\n\nheight: Height of the cylinder along the axis, default 1.0.\nradius: Radius of the circle, default 1.0.\ncenter: Center of the circle, default [0.0;0.0;0.0]\nsang: Start angle relative to the origin, default 0.0.\neang: End angle relative to the origin, default 2.0*π.\n\nOutput:\n\nsrf: NURBS surface of a extruded circular arc.\n\nExamples:\n\njulia> crv = nrbcylind()\njulia> crv = nrbcylind(height,radius)\njulia> crv = nrbcylind(height,radius)\njulia> crv = nrbcylind(height,radius,center)\njulia> crv = nrbcylind(height,radius,center,sang,eang)\n\nReferences:\n\nsee also nrbcirc\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#Test/Demo-Functions/Methods","page":"NURBS Toolbox","title":"Test/Demo Functions/Methods","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"nrbtestcrv\nnrbtestsrf\ndemoline\ndemorect\ndemocirc\ndemoellip\ndemocurve\ndemohelix\ndemocylind\ndemotorus\ndemorevolve\ndemodegelev\ndemokntins\ndemodercrv\ndemodersrf\ndemoruled\ndemocoons\ndemo4surf\ndemogeom","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtestcrv","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtestcrv","text":"nrbtestcrv()::NURBS1D\n\nConstruct a simple test curve.\n\nOutput:\n\ncrv NURBS data structure of a curve\n\nExamples:\n\njulia> crv = nrbtestcrv()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtestsrf","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.nrbtestsrf","text":"nrbtestsrf()::NURBS2D\n\nConstruct a simple test surface.\n\nOutput:\n\nsrf: NURBS data structure of a surface\n\nExamples:\n\njulia> srf = nrbtestsrf()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demoline","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demoline","text":"demoline()\n\nDemonstration of a 3D straight line\n\nExamples:\n\njulia> demoline()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demorect","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demorect","text":"demorect()\n\nDemonstrate of rectangluar curve.\n\nExamples:\n\njulia> demorect()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.democirc","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.democirc","text":"democirc()\n\nDemonstration of a circle arcs in the x-y plane.\n\nExamples:\n\njulia> democirc()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demoellip","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demoellip","text":"demoellip()\n\nDemonstration of a unit circle transformed to a inclined ellipse by first scaling, then rotating and finally translating.\n\nExamples:\n\njulia> demoellip()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.democurve","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.democurve","text":"democurve()\n\nShows two simple test curves.\n\nExamples:\n\njulia> democurve()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demohelix","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demohelix","text":"demohelix()\n\nDemonstration of a 3D helical curve.\n\nExamples:\n\njulia> demohelix()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.democylind","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.democylind","text":"democylind()\n\nDemonstration of the construction of a cylinder.\n\nExamples:\n\njulia> democylind()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demotorus","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demotorus","text":"demotorus()\n\nA second demonstration of surface construction.\n\nExamples:\n\njulia> demotorus()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demorevolve","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demorevolve","text":"demorevolve()\n\nDemonstration of surface construction by revolving a profile curve.\n\nExamples:\n\njulia> demorevolve()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demodegelev","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demodegelev","text":"demodegelev()\n\nDemonstration of the degree elevation algorithm.\n\nExamples:\n\njulia> demodegelev()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demokntins","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demokntins","text":"demokntins()\n\nDemonstration of the knot insertion algorithm.\n\nExamples:\n\njulia> demokntins()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demodercrv","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demodercrv","text":"demodercrv()\n\nDemonstrates the construction of a general curve and determine of the derivative.\n\nExamples:\n\njulia> demodercrv()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demodersrf","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demodersrf","text":"demodersrf()\n\nDemonstrates the construction of a general surface derivatives.\n\nExamples:\n\njulia> demodersrf()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demoruled","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demoruled","text":"demoruled()\n\nDemonstration of ruled surface construction.\n\nExamples:\n\njulia> demoruled()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.democoons","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.democoons","text":"democoons()\n\nConstruction of a bilinearly blended Coons surface.\n\nExamples:\n\njulia> democoons()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demo4surf","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demo4surf","text":"demo4surf()\n\nDemonstration of a bilinear surface.\n\nExamples:\n\njulia> demo4surf()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.demogeom","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.demogeom","text":"demogeom()\n\nDemonstration of how to construct a 2D geometric shape from a piece-wise set of NURBSs.\n\nExamples:\n\njulia> demogeom()\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#Private-Functions/Methods","page":"NURBS Toolbox","title":"Private Functions/Methods","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"bincoeff\nfactln","category":"page"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.bincoeff","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.bincoeff","text":"bincoeff(n::I,k::I) where{I<:Integer}\n\nComputes the binomial coefficient.\n\n( n )      n!\n(   ) = --------\n( k )   k!(n-k)!\n\nArguments:\n\nn: n of n choose k\nk: k of n choose k\n\nOutput:\n\nb: binomial coefficient of n choose k\n\nExample:\n\njulia> b = bincoeff(n,k)\n\nReference:\n\nAlgorithm 6.1.6 from 'Numerical Recipes in C', 2nd Edition pg215 (William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery (1992))\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#MagMechFEM_Matlab2Julia.NURBStoolbox.factln","page":"NURBS Toolbox","title":"MagMechFEM_Matlab2Julia.NURBStoolbox.factln","text":"factln(n::I) where{I<:Integer}\n\nComputes ln(n!).\n\nExample:\n\njulia> a = factln(n)\n\n\n\n\n\n","category":"function"},{"location":"doc_NURBStoolbox/#Index","page":"NURBS Toolbox","title":"Index","text":"","category":"section"},{"location":"doc_NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"Pages = [\"doc_NURBStoolbox.md\"]","category":"page"},{"location":"#MagMechFEM_Matlab2Julia","page":"Home","title":"MagMechFEM_Matlab2Julia","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 2","category":"page"},{"location":"#Licence","page":"Home","title":"Licence","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TODO","category":"page"},{"location":"#Third-party-code","page":"Home","title":"Third party code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package/Source Description\nNURBS Toolbox Toolbox for creation, manipulation and evaluation of NURBS structures (from Mark Spink (2000)). Licence: GPLv2. This dependency will be removed after the completion of the language port. As it is only needed to check against own implementations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This list might be incomplete or inaccurate as the original Matlab source files did not contain specific licence information and might have been modified after incorporation into the old project (which was not marked either).","category":"page"},{"location":"#Overview-over-Modules/Directories","page":"Home","title":"Overview over Modules/Directories","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Module/Directory Description\nIGA/nurbs_toolbox Toolbox for creation, manipulation and evaluation of NURBS structures (from Mark Spink (2000)).\nIGA/aHBS Module for the sparse adaptive creation and calculation of hierarchical NURBS levels. It adds furthermore routines for 3D calculation.","category":"page"},{"location":"#Further-remarks","page":"Home","title":"Further remarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Random collection of notes made to understand, debug and explain.","category":"page"},{"location":"NURBStoolbox/#NURBS-Toolbox","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"","category":"section"},{"location":"NURBStoolbox/#Licence","page":"NURBS Toolbox","title":"Licence","text":"","category":"section"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This toolbox is licensed under the GPLv2 licence as stated in the LICENSE.md file in its corresponding directory.","category":"page"},{"location":"NURBStoolbox/#Overview","page":"NURBS Toolbox","title":"Overview","text":"","category":"section"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This toolbox has been ported from Matlab to Julia as part of a bigger language porting project. Unfortunately the used files did not contain a file clearly indicating the licence. Therefore, the licence was set to GPLv2 assuming the roots and its original licence.","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"This package was originally written in 2000 by D.M. Spink for Matlab and Scilab[1]. And initially hosted on the MathWorks servers. It was reuploaded by a third party[2] this state of the packages is used in this port (Version 1.0 by Mark Spink (2000)). The seemingly original successor of the toolbox is the Octace community package nurbs[3] which is actively maintained. Some of the algorithms in this toolbox have been adopted from Les Piegl, Wayne Tiller (1997).","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The original description characterizing this toolbox has been published on the website of M. Spink[1]. Here is an excerpt of that site.","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The NURBS toolbox is collection of routines for the creation, and manipulation of Non-Uniform Rational B-Splines (NURBS). NURBS have to some extent become the de facto industry standard for representing complex geometric information in CAD, CAE and CAM, and are an integral part of many standard data exchange formats such as IGES, STEP and PHIGS.The toolbox is available for either Matlab or Scilab, and contains both script files and c routines to increase the performance. The intention of these toolboxes is not to provide the worlds fastest NURBS manipulation packages, but that coupled with the matlab/scilab environments they provide a friendly means for interactive research and algorithm prototyping.All the nurbs routines are prefix with nrb to differentiate them from any other similar sounding matlab script files by other authors. The data structure used to represent the NURBS in Matlab is compatible with that used in the Spline Toolbox by C. de Boor and The MathWorks, Inc and can be manipulated as four dimensional univariate or multivariate B-Splines. Both packages also include demonstration scripts that show examples on how to use the toolbox, and also online help is available.For a detailed explanation of NURBS and how to manipulate them, I can strongly recommend the book by Les Piegl and Wayne Tiller called 'The NURBS Book' ISBN 3-540-61545-8. Please note that the 'C' code algorithms is this library are modified versions of the pseudo-code within the book.[ ... ]The NURBS toolbox is provide free of any charges and has a GPL license. The source code is available for the Linux, Solaris and Windows, however should compile easily on other platforms.","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"I did not port the igesout function found in this toolbox as it is not main part of this toolbox, not necessary for this project and its licence was unclear[4].","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"[1]: Spink, M. (2016, Jan. 10) NURBS Toolbox. ARIA. http://aria.uklinux.net/nurbs.php3 accessible via WayBackMachine","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"[2]: Penguian (2010). NURBS Toolbox by D.M. Spink https://www.mathworks.com/matlabcentral/fileexchange/26390-nurbs-toolbox-by-d-m-spink, MATLAB Central File Exchange. Retrieved April 14, 2021.","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"[3]: M. Spink, D. Claxton, C. de Falco, R. Vazquez (2021-03-09) Nurbs. Octave Forge Community packages. https://octave.sourceforge.io/nurbs/index.html","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"[4]: Daniel Claxton (2021). igesout https://www.mathworks.com/matlabcentral/fileexchange/14470-igesout, MATLAB Central File Exchange. Retrieved April 21, 2021.","category":"page"},{"location":"NURBStoolbox/#Examples","page":"NURBS Toolbox","title":"Examples","text":"","category":"section"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemorect()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemocirc()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemogeom()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemoellip()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemocurve()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemohelix()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg,camera=[-45,25]) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemocylind()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg,camera=[-40,40]) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemotorus()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemorevolve()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemodegelev()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemodercrv()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemodersrf()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemoruled()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemo4surf()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"using MagMechFEM_Matlab2Julia.NURBStoolbox # hide\nusing Plots; # hide\nPlots.pyplot(); # hide\ndemocoons()\nplot!(background_color=:transparent,foreground_color=:grey,html_output_format=:svg) # hide","category":"page"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"For further examples see the NURBS Toolbox notebook.","category":"page"},{"location":"NURBStoolbox/#Documentation","page":"NURBS Toolbox","title":"Documentation","text":"","category":"section"},{"location":"NURBStoolbox/","page":"NURBS Toolbox","title":"NURBS Toolbox","text":"The documentation might provide a deeper understanding of the capabilities of the toolbox.","category":"page"}]
}
